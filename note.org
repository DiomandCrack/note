#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./org-style.css" />
#+title: JavaScript 学习笔记
* 20170905
** 初识 JavaScript
*** 基本概念
    JavaScript 原名叫LiveScript 是一种基于对象和事件驱动的客户端脚本语言，
最初的设计是为了检验HTML表单输入的正确性。

*** 基本组成
    完整的JavaScript是由3部分组成:
    - ECMAScript(5.1)规定了JS的基本语法
    - BOM 浏览器对象模型
    - DOM 文档对象模型

*** 在HTML中使用JS
    - 内嵌在HTML当中
    - 外链JS文件

** JS的基本语法

*** 注释
    单行注释  src_js[:exports code]{//}

    多行注释 
   #+BEGIN_SRC js
    /*
    1...
    2...
    3...
    */
    #+END_SRC

*** 标识符
    标识符:

    变量名、常量名、函数名、函数参数名、对象属性名的统称

    标识符的命名规则:
    - 由数字、字母、下划线和美元符($)组成
    - 首字符不能使用数字
    - 不能使用JS的关键字和保留字

    标识符的名字可以是任意长度

*** 变量
     1.什么是变量？

     标识符的一种，是一种变化的量，它的作用就是用来储存数据的

     2.如何声明一个变量？

     使用关键字  var 变量的名字

     3.第一个运算符：赋值运算符

     " = " 一个等号代表赋值，而不是等于，意思是把等号右边的东西给左边

     4.如果声明一个变量，没有初始化那么默认值是： undefined (未定义的意思)
      
     声明了一个变量，并且命名为 a;

     #+BEGIN_SRC js
     var a;
     #+END_SRC

     声明了一个变量，命名为b并且初始化了一个数据是一个数字 1

     #+BEGIN_SRC js
     var b = 1;
     #+END_SRC

     同时声明多个变量的时候可以使用 “,” 分开

     #+BEGIN_SRC js
     var a = 1;
     var b = 2;
     var c = 3;
     #+END_SRC

     和上面是一个意思
     #+BEGIN_SRC js
     var a = 1, b = 2, c = 3;
     #+END_SRC

*** console.log 
      向控制台打印内容：
      
      console.log(要输出打印的内容);

     #+BEGIN_SRC js 
     console.log('hello world');

     console.log('123');//加了引号叫字符串
     #+END_SRC

*** 获取元素对象

    元素对象
    
    1.通过ID获取元素

    #+BEGIN_SRC js
      document.getElementById('id');
    #+END_SRC

    2.通过CSS选择器获取元素


    #+BEGIN_SRC js
      document.querySelector('css选择器');
    #+END_SRC

    元素对象也是一种数据


    #+BEGIN_SRC js
      var box = document.getElementById('box');
      console.log(box);
    #+END_SRC
    
    像getElementById 这种命名方式，叫驼峰命名法

    下面的方式只会获取第一个
    #+BEGIN_SRC js
      var box = document.querySelector('.box');
      var box = document.querySelector('div');
    #+END_SRC

*** 书写JS的基本流程
    
    1. HTML + CSS 布局
    2. 对案例进行分析(功能)
    3. 结合已经学过的JS语法书写代码

*** 事件 
    事件：文档或浏览器发生一些特定交互的瞬间
    鼠标事件
    - 点击事件 onclick
    - 鼠标移入事件 onmouseover
    - 鼠标移出事件 onmouseout

*** 函数
    初始函数:
    1. 什么是函数？

    可以封装任意多条语句，代表一个功能的整体。

    2. 声明一个函数:

    使用关键字 src_js[:exports code]{function 函数名(){...}}

    3. 放在函数内的代码不会主动执行

    4. 函数的调用
       -函数名();
       -通过事件去调用

    5. 匿名函数
       src_js[:exports code]{function (){...}} 匿名函数不能单独存在，可以通过事件去调用

    #+BEGIN_SRC js
    box.onclick = function (){
    oalert(1);
};
    #+END_SRC
     
    6. 函数和CSS里面的class非常类似，可以被复用

    #+BEGIN_SRC js
    function fn1(){
    var a = 1;
    var b = 2;
    console.log(a+b);
}
     //fn1();
    var box = document.querySelector('.box');

    box.onclick = fn1;

    var box = document.querySelector('div');

    box.onclick = fn1;
    #+END_SRC

** 实现
    #+BEGIN_SRC HTML
      <button id="btn">按钮</button>

      <div class="box"></div>
   #+END_SRC 


    #+BEGIN_SRC css
       #btn {
	    width: 150px;
	    height: 40px;
	  }

       .box {
	    width: 200px;
	    height: 200px;
	    background: goldenrod;
	    transition: 0.5s;
	  }
    #+END_SRC


    #+BEGIN_SRC js
	  // 获取元素
	  var btn = document.querySelector('#btn');
	  var box = document.querySelector('.box');
    
	  btn.onclick = function (){
	    // 找到box给它的style属性里面的width属性赋值为300px
	    box.style.width = '300px';
	    box.style.height = '300px';
	  };
    #+END_SRC

** 总结

     1.基本语法：
        - 注释
        - 严格区分大小写
        - 每个语句后面都加 ';'
     2.标识符

     3.变量

     4.数据: 数字 undefined null(空)

     5.获取元素的方法 (如果通过id获取，那么尽量使用
src_js[:exports code]{document.getElementById('id');})

     6.事件

     7.函数

     8.给某个元素对象设置行间样式(属性操作)

     9.src_js[:exports code]{window.onload}

* 20170906

** 元素的属性操作

   元素对象的属性操作是指操作元素的行间属性

   元素对象的属性操作主要包括2个部分:

   -属性的读操作:

     元素.属性的名字,还可以使用元素['属性的名字'],能用 "."的地方都能用"[]",能通"[]"的地方
不一定都能用"."


   -属性的写操作:

     元素.属性的名字 = 新的值

     元素['属性的名字'] = 新的值

    #+BEGIN_SRC js
    var text = document.querySelector('.text');
    
    console.log(text.type);   // type 叫做属性的名字(key),'text'又叫做属性对应的值 'value'
    
    console.log(text['value']);
    
    // document 文档，也是一个对象
    
    document.onclick = function (){
      // text.value = 456;
      text['value'] = 456;
    };
    #+END_SRC

** 获取文本框的值

   #+BEGIN_SRC html
    <input type="text" class="text">
     <!-- input虽然没有声明value属性，但是默认还是有值的，这个值是一个 '' -->
    <input type="button" value="按钮" class="btn">
   #+END_SRC

   步骤：

   1.让文本框自动聚焦

   2.点击按钮，首先获取到文本框的值

   3.弹出(打印)获取到的值

   4.清空文本框，病情让文本框重新聚焦


   #+BEGIN_SRC js
     var text = document.querySelector('.text');
     var btn = document.querySelector('.btn');
    
     // 让文本框自动聚焦
     text.focus();

     btn.onclick = function (){
	   console.log(text.value);
	   text.value = '';
	   text.focus();
     };
   #+END_SRC

** 设置元素的样式

   #+BEGIN_SRC html
     <input type="text" value="" class="text1">
     <input type="text" value="" class="text2">
     <button class="btn">设置</button>
     <div class="box"></div>
  #+END_SRC


  #+BEGIN_SRC js
	/*
	    1 点击按钮 拿到两个文本框的内容
	    2 将两个文本框的内容设置为box的属性和对应的值
	  */
    
	var text1 = document.querySelector('.text1');
	var text2 = document.querySelector('.text2');
	var btn = document.querySelector('.btn');
	var box = document.querySelector('.box');
	//console.log(text1,text2,btn,boxh)
	btn.onclick = function (){
	  var key = text1.value;  // key = 'width'
	  var val = text2.value;
      
	  // console.log(key, val);
      
	  box.style[key] = val;
	};
    
  #+END_SRC

** 操作元素的class

   #+BEGIN_SRC html
       <button class="btn">按钮</button>
       <div class="red"></div>
   #+END_SRC

   #+BEGIN_SRC css
	 div {
	   width: 200px;
	   height: 200px;
	 }
	 .red {
	   background: red;
	 }
	 .blue {
	   background: blue;
	 }
	 .btn {
	   width: 200px;
	   height: 40px;
	   margin: 10px;
	   }
   #+END_SRC

   #+BEGIN_SRC js
	 /*
	   需求：点击按钮修改div的class从red变为blue
	  */
    
	 var btn = document.querySelector('.btn');
	 var box = document.querySelector('.red');
    
	 btn.onclick = function (){
	   // box.class = 'blue';
	   // console.log(box.class);
	   // class 是JS的关键字，想操作元素的class需要使用className
	   // console.log(box.className);
	   box.className = 'blue';
	 };
  
   #+END_SRC

** 获取属性的一些注意事项
   
   #+BEGIN_SRC html
     <div class="box" style="width:100px;height:100px;background:#f00;">123</div>
     <img src="./img/1.jpg" width="600">
   #+END_SRC


   #+BEGIN_SRC js
	 var box = document.querySelector('.box');
   #+END_SRC 
   属性操作获取的颜色不一定准确
   #+BEGIN_SRC js
   console.log(box.style.background);
   #+END_SRC 
   属性的读取，读取的都是行间的样式，如果行间没有设置，那么是获取不到的。
   #+BEGIN_SRC js
   console.log(box.style.display);
   #+END_SRC
    图片的src属性，获取到的是一个绝对路径
    #+BEGIN_SRC js
    var img = document.querySelector('img');
    //console.log(img.src);
   #+END_SRC

** innerHTML

      innerHTML 表示元素标签内的 html 内容的
      元素.innerHTML  获取某个元素内的html内容
      元素.innerHTML = '新的内容';  修改某个元素内的html内容
      innerHTML 获取到的内容和操作的内容都是字符串


      #+BEGIN_SRC js
	    var title = document.getElementById('title');
    
	    // 获取html内容
	    // console.log(title.innerHTML);
    
	    document.onclick = function (){
	      // 设置html内容
	      title.innerHTML = '<img src="./img/2.jpg" width="600" />';
	    };
      #+END_SRC

** 字符串的基本操作
   字符串：由0个或者多个字符组成的字符序列，并且放在一对引号或者反引号中
   
   1.length 用来获取某个字符串的长度的，它只能读不能写

       字符串.length

   2.字符串一但创建，就不能修改

   3.简单的字符串操作：字符串的拼接

      运算符 +
    

   #+BEGIN_SRC js
	 var str = 'hello';
    
	 console.log(str.length);  // 5 代表当前字符串的长度
	 
	  str.length = 3;   
	  // 字符串一旦创建就不可以再改变，所以它的length属性只可以读取不可以修改
   #+END_SRC

   字符串的操作


   #+BEGIN_SRC js
     var str1 = 'hello';
     var str2 = 'world!'; 

     var str3 = str1 + str2;   // 'helloworld!'
     console.log(str3);
 
     console.log('1' + 1); // '11'
     console.log('1' + '2'); // '12'
     
     var str = 'a';
     var str = 'b';
     str += 'b'
     console.log(str); //'ab'
   #+END_SRC

   当做加法运算的时候，如果表达式里面有一个是字符串，那么不做加和操作，而是做字符
串的拼接操作。而且在数学运算符号中，只有+是这样的


#+BEGIN_SRC js
  console.log('1'/1); // 1
#+END_SRC

** 简单的留言板
   
   1.点击按钮获取到文本框的内容

   2.把这个获取到的value 变成  <li>value</li>

   3.把获取到的这个值放到ul当中，也就是操作ul的innerHTML
   
   #+BEGIN_SRC html
       <ul class="leaveMessage"></ul>
       <input type="text" class="text" value="">
       <input type="button" class="btn" value="发送">
   #+END_SRC

   #+BEGIN_SRC css
	 ul {
	   width: 300px;
	   height: 400px;
	   border: 1px solid #000;
	 }
   #+END_SRC

   #+BEGIN_SRC js
     var leaveMessage = document.querySelector('.leaveMessage');
     var text = document.querySelector('.text');
     var btn = document.querySelector('.btn');
    
     text.focus();
   
     btn.onclick = function (){
	 var val = text.value;   // val = '123'
	   // console.log('<li>' + val + '</li>');
      
	   // innerHTML 会先清空之前的内容，然后再添加新的内容
	   // var prevHtml = leaveMessage.innerHTML;
	   // console.log(prevHtml);
      
	   // leaveMessage.innerHTML = '<li>' + val + '</li>' + prevHtml;
      
	   // leaveMessage.innerHTML += '<li>'+val+'</li>';
      
	   /* leaveMessage.innerHTML += `<li>
					  <div>
					    <span>
					      ${val}
					    </span>
					  </div>
					</li>`;
	   ,*/
	 text.value = '';
	 text.focus();
     }
   #+END_SRC

** 用classList操作元素的class
   
   #+BEGIN_SRC html
     <div class="box1 box2"></div>
   #+END_SRC


   #+BEGIN_SRC css
	 .box1 {
	   width: 100px;
	   height: 100px;
	   background-color: red;
	 }
	 .box2 {
	   transform: rotate(45deg);    }
	 .box3 {
	   border: 5px solid green;
	 }
   #+END_SRC


   #+BEGIN_SRC js
     var box = document.querySelector('.box1');
  
	 // console.log(box.className);
    
	 // box.className += ' box2 box3'; 
	 // 
	 // box.className = 'box1 box3';
    
	 // 元素.classList  它是元素的所有的class的一个集合;
	 // 元素.classList.add('class的名字');
	 // 元素.classList.remove('class的名字');
    
	 // console.log(box.classList);

     box.classList.add('box2');

     box.classList.add('box3');

     box.classList.remove('box2');
  
   #+END_SRC

** 小结
   1.属性操作 （读和写） . 和 []

   2.属性操作的注意事项 背景颜色、img.src、属性操作的是行间样式， 操作元素的class用className
  
   3.innerHTML

   4.字符串  length  字符串的拼接  +  += 
  
   5.box.style['background-color'] 当使用一个不符合标识符命名规范的属性的时候
   
* [[file:D:\学习指南\2-javascript\date\20170907.org][20170907]]
** 比较操作符和布尔值

      比较操作符

      "==" 只比较值，而不比较数据类型

      "==="  严格比较，不仅仅比较值，而且还比较类型
     
      > 大于号、 >= 大于等于

      < 小于号、 <= 小于等于
     
     ! 取反、非
     
     他们操作的结果，最终返回的要么是一个 true,要么是一个false，这两个值叫做 布尔值

** 流程控制:判断

       判断的基本语法

       if(条件){

        条件成立时候执行的代码(这里面的代码只有当条件成立的时候才会执行)

       }


       #+BEGIN_SRC js
	      var age = 17;
     
	      if(age >= 18){
		alert('成年了!');
	      }
       #+END_SRC

        if(条件1){

	条件1成立时候的代码

        }else{

             如果条件1不成立那么执行这里面的代码

        }


	#+BEGIN_SRC js
	       var h = 1; 
	       if(h > 1){
		 alert('付钱')
	       }else{
		 alert('免费')
	       }
	#+END_SRC

    获取星期  src_js[:exports code]{new Date().getDay();}


    #+BEGIN_SRC js
	  if(day === 1){
	     alert('星期一');
	   }else if(day === 2){
	     alert('星期二');
	   }else if(day === 0){
	     alert('星期日')
	   }else if(day === 3){
	     alert('星期三')
	   }else if(day === 4){
	     alert('星期四')
	   }else if(day === 5){
	     alert('星期五')
	   }else if(day === 6){
	     alert('星期六')
	   }
    #+END_SRC

只要有一个条件成立,
那么后面的条件即使成立也不会执行。


#+BEGIN_SRC js
      var num = 10;
    
      if(num <= 10){
	alert(1);
      }else if(num >= 10){
	alert(2);
      }else if(num == 10){
	alert(3);
      }else{
	alert(4);
      }
#+END_SRC



** 三元操作符
   三元操作符又叫做三元表达式

*条件成立吗* ？ *成立就执行这句话* : *条件不成立执行的代码*;


#+BEGIN_SRC js
  var age =19;

  age >= 18 ? alert(1) : alert(2);

  /*if(age>=18){
      alert(1);
  }else{
      alert(2);
  }*/
#+END_SRC

如果else之后不想做什么 也要写个空字符串


#+BEGIN_SRC js
  var age =19;
  age >= 18 ? alert(1) : '';
#+END_SRC

** 让div显示消失

   点击按钮, 让div显示和隐藏

   如果这个div是显示的那么就隐藏，如果是隐藏的就显示

   #+BEGIN_SRC html
     <button class="btn">按钮</button>
     <div class="box"></div>
   #+END_SRC


   #+BEGIN_SRC js
	 var btn = document.querySelector('.btn');
	 var box = document.querySelector('.box');
	 if(box.style.display === 'block'){ 
	    box.style.display = 'none';
	 }else{
	    box.style.display = 'block';
	 }
   #+END_SRC

   如果发现眼下已知的条件解决不了当下的问题,那么首先想到一件事,
   回过头去声明一个变量。


   #+BEGIN_SRC js
       if(showAble){
	      box.style.display = 'none';
	    }else{
	      box.style.display = 'block';
	    }
       showAble = !showAble;
      
   #+END_SRC
    
   三元表达式为：

   #+BEGIN_SRC js
	 box.style.display = showAble ? 'none' : 'block';
	 showAble = !showAble;
   #+END_SRC

** 两张图片切换

   点击图片，如果是1.jpg就变成2.jpg，否则就是1.jpg。

   #+BEGIN_SRC html
     <img src="img/1.jpg" width="600">
   #+END_SRC


   #+BEGIN_SRC js
     var img = document.querySelector('img');
     var first = true;
    
     img.onclick = function (){
	  if(first){
	    img.src = 'img/2.jpg';
	    first = false;
	   }else{
	       img.src = 'img/1.jpg';
	       first = true;
	   }
	 };
   #+END_SRC
   
   三元表达式为：

   #+BEGIN_SRC js
	   img.src = first ? 'img/2.jpg' : 'img/1.jpg';
	   first = !first;
   #+END_SRC

** 自增自减

   + 加  - 减
   % 取模 求余数
   ** 求n次方


   #+BEGIN_SRC js
     console.log(1 + 1);  //2
     console.log(1 - 2); // -1
     console.log(2%5); // 2
   #+END_SRC


   #+BEGIN_SRC js
     var a = 1;
     a = a + 2;
     a += 2;

     console.log(a); //3
   #+END_SRC

    自增和自减
    自增就是某个数值+1，自减就是某个数值-1
    自增分为前自增和后自增，在单独使用的时候没有任何区别。
    只有当在运算或者在其他表达式中的时候，那么前自增是自己先加1，
    然后再参与运算，后自增先参与运算，自己再加1
    
    前自减

    #+BEGIN_SRC js
      var a = 2;

      b = --a;
      console.log(a,b) // 1 1
    #+END_SRC

    后自减
    
    #+BEGIN_SRC js
      var a = 2

      b = a--；
      console.log(a,b); // 1 2
    #+END_SRC
    
** 边界判断

   点击 - 让value -1，当小于0的时候，就不能再 - 
   点击+ 让value+1，当大于4的时候，就不能再+
   #+BEGIN_SRC html
   <button class="sub">-</button>
   <input type="text" class="text" value="0">
   <button class="add">+</button>
   #+END_SRC

   #+BEGIN_SRC js
	 var sub = document.querySelector('.sub');
	 var add = document.querySelector('.add');
	 var text = document.querySelector('.text');
    
	 var num = 0;
    
	 sub.onclick = function (){
	   if(num > 0){
	     num--;
	   }
	   text.value = num;
	 };
    
	 add.onclick = function (){
	   if(num < 4){
	     num++;
	   }
	   text.value = num;
	 };
   #+END_SRC

** 循环判断
   
   点击- ，让value值-1，当小于0的时候，就变成4
   点击-，让value值+1，当大于4的时候，就变成0

   #+BEGIN_SRC html
   <button class="sub">-</button>
   <input type="text" class="text" value="0">
   <button class="add">+</button>
   #+END_SRC

   

   #+BEGIN_SRC js
      var sub = document.querySelector('.sub');
      var add = document.querySelector('.add');
      var text = document.querySelector('.text');
   
      var num = 0;
   
      sub.onclick = function (){
	   if(num > 0){
	     num--;
	   }else{
	     num = 4;
	   }
    
	 //num = num > 0 ? --num : 4;//三元表达式
    
	  text.value = num;
	};
   
	add.onclick = function (){
	   if(num < 4){
	     num++;
	   }else{
	     num = 0;
	   }
	 // num = num < 4 ? ++num : 0;//三元表达式
	  text.value = num;
	}; 
   #+END_SRC

** 小结 
    比较操作符和布尔值
    流程控制：判断
    三元表达式
    ++ --
    !
    + - * / % **
      
* 20170908
  
** [[D:\学习指南\2-javascript\20170908\01_图片切换案例.html][图片切换案例]]

   点击上一张，如果是第一张那么就切换到最后一张，否则切换到上一张
   点击下一张，如果是最后一张那么就切换到第一张，否则切换到下一张

#+BEGIN_SRC html
  <button class="prev">prev</button>
  <button class="next">next</button>
  <img src="" class="img" width="400" />
#+END_SRC


#+BEGIN_SRC js
    var prev = document.querySelector('.prev');
      var next = document.querySelector('.next');
      var img = document.querySelector('.img');
    
      var current = 1;
    
      // 初始化操作
      init();
    
      function init(){
	img.src = './img1/'+current+'.jpg';
      }
    
      // 上一张
      prev.onclick = function (){
	current--;
	if(current < 1){
	  current = 4;
	}
	// console.log(current);
	// img.src = './img1/'+current+'.jpg';
	init();
      };
    
      // 下一张
      next.onclick = function (){
	current++;
	if(current > 4){
	  current = 1;
	}
	// img.src = './img1/'+current+'.jpg';
	init();
      };
#+END_SRC

** 数组的基本使用

     声明一个数组： [],

     数组里面的每一项用 , 隔开，最后一项后面不能加 ,

     数组里面可以储存任意类型的数据

     想使用数组里面的数据可以通过下标的方式

     length 属性 代表数组的长度， 是可读可写的


     #+BEGIN_SRC js
       var arr = [0, 1, 2, 3, 4];
     #+END_SRC

也可以写成这样

     #+BEGIN_SRC js
       var arr1 = [
	   0,
	   1,
	   2,
	   3,
	   4
	    ]
     #+END_SRC

数组里面可以储存任意类型的数据，包括数组本身。


#+BEGIN_SRC js
   var arr = ['a', 123, function(){}, ['1', 'hello']];
#+END_SRC

数组也是一个对象，可以通过下标(索引值)的方式获取数组中对应的数据

#+BEGIN_SRC js
  console.log(arr['0']);
  console.log(arr[0]);
#+END_SRC

数组的属性length,代表数组的长度


#+BEGIN_SRC js
  var arr = ['a', 'b', 'c', 'd'];
    
  console.log(arr.length); //4
  console.log(arr[0]); //数组的第一个
  console.log(arr[arr.length - 1]); //数组的最后一个

  arr.length = 1 ; //数组的length属性不仅仅可以读取还可以修改

  arr.length = 10; //数组多余的位置为undefined

  var arr[ 3,2,['a',['b']],1];

  console.log(arrp[2][1][0]);//数组存在多维
#+END_SRC

** [[D:\学习指南\2-javascript\20170908\03_图片切换名字随意.html][切换任意名字的图片]]

#+BEGIN_SRC html
  <button class="prev">prev</button>
  <button class="next">next</button>
  <p class="currentItem">0/0</p>
  <img src="" class="img" width="400" />
#+END_SRC


#+BEGIN_SRC js
   var imgData = [
	'./img2/asd.jpg',
	'./img2/fasd.jpg',
	'./img2/hgj.jpg',
	'./img2/timg.jpg'
      ];
    
      //上一张
      var prev = document.querySelector('.prev');
      //下一张
      var next = document.querySelector('.next');
      // 数量
      var num = document.querySelector('.currentItem');
      // 图片
      var img = document.querySelector('.img');
    
      // console.log(prev, next, num, img);
    
      var index = 0, len = imgData.length;
    
      // 初始化页面操作
      init();
    
      function init(){
	num.innerHTML = (index + 1) + '/' + len;
	img.src = imgData[index];
      }
    
      // 点击上一张
      prev.onclick = function (){
	index--;
	if(index < 0){
	  alert('已经是第一张了!');
	  index = 0;
	}
       init();
	// num.innerHTML = (index + 1) + '/' + len;
	// img.src = imgData[index];	
      };
    
      // 点击下一张
      next.onclick = function (){
	index++;
	if(index > len - 1){
	  alert('已经是最后一张了!');
	  index = len - 1;
	}
	init();
       // num.innerHTML = (index + 1) + '/' + len;
       // img.src = imgData[index];
      };
#+END_SRC

** 控制流程: 循环
   
     循环：用来帮你做重复的事（有规律的事、差不多的事）
     关键字 for(初始化的条件 var i=0; 判断条件 i<5; 条件变换 i++)
     {
         如果条件成立，那么就执行这里面的代码（循环体）
     }
     两个 ;; 比不可少
     
     1.执行初始化条件 （只执行一次）
     2.看判断条件是否成立，如果成立，那么执行循环体的代码，如果不成立就跳出循环
     3.如果第二步的条件成立了，执行完循环体的代码之后，执行条件变换
     4.重复 2 3 步
     

     #+BEGIN_SRC js
	   for(var i=0; i<5; i++){
	     console.log(123);
	   }
    
	   console.log(i);   // 循环完成之后 i 的值 就是5
    
	   for(var i=5; i>=0; i--){
	     console.log(i); // 5 4 3 2 1 0
	   }
    
	   console.log(i);  // -1
    
    
	   for(var i=0, len=5; i<len; i++){
	     console.log(i);
	   }
    
	 for(var i=0, j=0; i<3, j<2; i++, j++){
	     console.log(1);
	   }
	   console.log(i,j);
	   console.log(i + j);  // 4  

	   for(;;){   // 死循环
	     alert(1);
	   }
     #+END_SRC

** 循环遍历数组

   #+BEGIN_SRC js
         var arr = [2, 3, 4, 5];
   #+END_SRC

等价于:

   #+BEGIN_SRC js
     var arr[0] = 2;
     var arr[1] = 3;
     var arr[2] = 4;
     var arr[3] = 5;
   #+END_SRC

用循环遍历数组

#+BEGIN_SRC js
  for (var i = 0){
      console.log(arr[i]); //2 3 4 5
  }

  for (var i = 0, len = arr.length ; i<len; i++){
      console.log(arr[i]);
  }
#+END_SRC

** 生成10w个div

向class为box的div里面生成10w个div每个div里面的innerHTML就是本次循环 i 的值

#+BEGIN_SRC html
  <div class="box">
  </div>
#+END_SRC

#+BEGIN_SRC js
  var box = document.querySelector('.box');

  var str = '';

  for(var i=0; i<100000; i++){
      str +='<div>'+i+'</div>';
  }

  box.innerHTML =str;
#+END_SRC

** 遍历查找特定的值

找到所有的偶数


#+BEGIN_SRC js
      var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    
      for(var i=0, len=arr.length; i<len; i++){
        var item = arr[i];
        if(item % 2 === 0){
            console.log(item);
        }
      }
#+END_SRC

循环控制

break

continue

通常都会配合if判断来使用


#+BEGIN_SRC js
      for(var i=0; i<5; i++){
        if(i === 3){
          break;  // 当条件成立的时候。使用了break，那么循环就会在这次之后中断。
        }
        console.log(i);
      }
    
      for(var i=0; i<5; i++){
        if(i === 3){
          continue;  // 跳过本次循环，继续后面的循环
        }
        console.log(i);
      }
    
#+END_SRC

    "!=" 不严格不等于  "!==" 严格不等于 

    #+BEGIN_SRC js
      console('0' != 0); //false '0' 能转换成0 '0'等于0
      console('0' !==0); // true 严格比较 '0'不等于0 
    #+END_SRC

** 对数组中的数值进行求和

   累加
          0 + 1 = 1;  // num = 1
          1 + 2 = 3;  // num = 3;
          3 + 3 = 6;  // num = 6;
          6 + 4 = 10; // num = 10;
         10 + 5 = 15;// num = 15

   #+BEGIN_SRC js
     var arr = [1, 2, 3, 4, 5];

     // 0 + 1 + 2 + 3 + 4 + 5
     var num = 0;

     for(var i=0, len=arr.length; i<len; i++){
       num += arr[i];
     }

     console.log(num);
   #+END_SRC

** 找到数组中的最大值和最小值


   #+BEGIN_SRC js
     var arr = [6, 21, 3, 40, 5];

     // 求出数组中的最大值

     var num = arr[0];  // 先设定一个值 遍历数组中的每个值比较大小
   #+END_SRC
     6 < arr[1] ? 6 < 21 ==> num = 21;

     21 < arr[2] ? 3 < num = 21;

     21 < arr[3] ? 21< 40 ==> num = 40;

     40 < arr[4] ? 5<  num = 40;

  #+BEGIN_SRC js
         for(var i=0, len=arr.length; i<len; i++){
           if(num < arr[i]){
             num = arr[i];
           }
         }
 #+END_SRC
  6>arr[1] ?  num =6<21;

  6>arr[2] ?  6>3 ==> num =3;

  3>arr[3] ? num = 3 < 40;

  3>arr[4] ? num=3 < 5;

#+BEGIN_SRC js
  for(var i=0, len=arr.length; i<len; i++){
    if(num > arr[i]){
      num = arr[i];
    }
  }
   console.log(num);
   #+END_SRC

* 20170911
** [[D:\学习指南\2-javascript\20170911\01_生成一排10个div.html][生成一排10个div]]

   #+BEGIN_SRC html
       <div class="box">
         <!-- <div style="left: 0;">1</div>
         <div style="left: 60px;">2</div>
         <div style="left: 120px;">3</div>
         <div style="left: 180px;">4</div>
         <div style="left: 240px;">5</div>
         <div style="left: 300px;">6</div>
         <div style="left: 360px;">7</div>
         <div style="left: 420px;">8</div>
         <div style="left: 480px;">9</div>
         <div style="left: 540px;">10</div> -->
       </div>
   #+END_SRC


   #+BEGIN_SRC css
         .box {
           position: relative;
         }
         .box div {
           width: 50px;
           height: 50px;
           position: absolute;
           background-color: red;
           color: #fff;
           text-align: center;
           line-height: 50px;
           font-size: 20px;
         }
   #+END_SRC


   #+BEGIN_SRC js
     var box = document.querySelector('.box');

     var str = '';

     for(var i = 0; i<10; i++){
         str+=`<div style="left: ${i*60}px;"> ${i+1} </div>`
     }
     box.innerHTML = str;
   #+END_SRC

** [[D:\学习指南\2-javascript\20170911\02_生成10乘10的方格.html][生成10个10排的div]]
#+BEGIN_SRC html
    <button>按钮</button>
    <div class="box">
    
    </div>
#+END_SRC


#+BEGIN_SRC css
      .box {
        position: relative;
      }
      button {
        width: 150px;
        height: 40px;
        margin: 10px;
      }
      .box div {
        width: 50px;
        height: 50px;
        position: absolute;
        background-color: red;
        /*color: #fff;*/
        text-align: center;
        line-height: 50px;
        font-size: 20px;
      }
    
#+END_SRC

生成10*10的div矩阵，并且颜色是依次排开的
第一次点击按钮可以生成。生成后再点击按钮无效

#+BEGIN_SRC js
    var box = document.querySelector('.box');
    var btn = document.querySelector('button');
    
    var size = 60;
    var colors = ['red', 'yellow', 'blue', 'green'];

    var str = '';
#+END_SRC

第一种方案
#+BEGIN_SRC js
  for(var i = 0; i<10 ; i++){//当循环嵌套循环的时候，两个循环不能用同一个变量
      for(var j = 0 ; j<10 ; j++){
          str +='<div style ="left:${j*size}px;top:${i*size}px;background-color:${colors[(j + 10*i)%colors.length]};">${j+10*i}</div>'
      }
  }
  box.innerHTML = str;
#+END_SRC
第二种方案

#+BEGIN_SRC js
  var t = -1;

  for(var i = 0; i<100 ; i++){
      if(i%10 ===0 ){
          //折行的条件
          t++
      }
      str += `<div style = "left:${i%10*size}px;top:${t*size}px;background-color:${colors[i%colors.length]};">${i}</div>`;
  }

  box.innerHTML = str;
#+END_SRC

第三种方案


#+BEGIN_SRC js
  var first = true;

  btn.onclick = function (){
      if(first){
          var str = '';
          for(var i=0; i<100; i++){
              str +=`<div style="left:${i%10*size}px;top:${~~(i/10)*size}px;background-color:${color[i%colors.length]};">${i}</div>`
          }
          box.innerHTML = str;
          first = false;
      }
  };
#+END_SRC
[[D:\学习指南\2-javascript\练习\09011div\100.html][我的方案]]


#+BEGIN_SRC html
      <button class="btn">按钮</button>
      <div class="box">
      </div>
#+END_SRC


#+BEGIN_SRC css
       .box{
       height: auto;
       display: flex;
       flex-flow: row wrap;
       }
       .item{
       width:50px;
       line-height: 50px;
       margin-right: 10px;
       margin-top: 10px;
       color:#fff;
       text-align: center;
       vertical-align: middle;
       }
       .btn{
       width: 100px;
       height: 50px;
       }
#+END_SRC

#+BEGIN_SRC js
       var btn = document.querySelector('.btn');
       var box = document.querySelector('.box');
       var item = document.querySelector('.item');
       var string = '';
       var array = ['red','orange','yellow','green','cyan','blue','purple','black','gray','skyblue']
       var onOff = true;
       var num=10;
       btn.onclick = function (){
       box.style.width = 60*num+'px';
       if(onOff){
       for(var i=0 ; i<100 ; i++){
           string += '<div class="item" style="background:'+array[i%array.length]+'">'+i+'</div>';
	     
       }
           box.innerHTML = string;
           onOff=!onOff;
       }
       };
#+END_SRC

** 遍历二维数组
一维数组


#+BEGIN_SRC js
  var arr1 = [1,2,3,4]
#+END_SRC

二维数组(二维非对称二维数组)

非对称二维数组
#+BEGIN_SRC js
  var arr1 = [
      ['a','b','c'],
      ['d','e'],
      [1,2,3,4,5]
  ];
#+END_SRC

对称二维数组

#+BEGIN_SRC js
  var arr2 = [
      [1,2,3],
      [4,5,6],
      [7,8,9]
  ];
#+END_SRC

遍历一个二维数组


#+BEGIN_SRC js
  for(var i=0; i<arr1.length; i++){
      console.log(arr[i]); //每一个又是一个数组
      for(var j=0; j<arr[i].length; j++){
          console.log(arr1[i][j]);
      }
  }
#+END_SRC

第几次循环就循环几次


#+BEGIN_SRC js
  var arr3 = [
      [1],
      [2,3],
      [4,5,6]
  ]

  for(var i=0; i<arr3.length; i++){
      for(var j=0; j<=i; j++){
          console.log(arr3[i][j]);
      }
  }
#+END_SRC

** [[D:\学习指南\2-javascript\20170911\04_99乘法表.html][乘法口诀]]

   #+BEGIN_SRC css
      .box span {
           width: 100px;
           height: 40px;
           line-height: 40px;
           text-align: center;
           display: inline-block;
           border: 1px solid #000;
           margin: 2px;
      }
   #+END_SRC


   #+BEGIN_SRC js
      var box = document.querySelector('.box');
    
         var str = '';
    
         for(var i=1; i<=9; i++){
           for(var j=1; j<=i; j++){
             str += '<span>'+i+' * '+j+' = '+(i*j)+'</span>'
           }
           str += '<br />';
         }
    
         box.innerHTML = str;
   #+END_SRC

** 小结
   for循环，可以和for循环进行嵌套，循环嵌套循环的时候不能使用同一个变量。

   二维数组以及如何遍历二维数组

   99乘法表（第几次循环就循环几次）

   ~~取整
** 注意

   #+BEGIN_SRC js
     for(var i=0; i<3 ;i++){
         document.onclick = function (){
             alert(i); //弹出3 事件里面的i是循环完成以后的i
         };
     }
   #+END_SRC

* 20170912
** 获取一组元素

   #+BEGIN_SRC html
     <div class="list">
       <div class="list-item">1</div>
       <div class="list-item">2</div>
       <div class="list-item">3</div>
     </div>
     <div class="list2">
       <div class="list-item">3</div>
       <div class="list-item">4</div>
       <div class="list-item">5</div>
     </div>
     <div class="list3">
       <div class="list-item">1</div>
       <div class="list-item">2</div>
     </div>
   #+END_SRC

*** 通过类选择器获取一组元素
 元素对象.querySelectorAll('css选择器');

#+BEGIN_SRC js
  var items = document.querySelectorAll('.list-item');
#+END_SRC

选取.list中的.list-item


#+BEGIN_SRC js
  var list = document.querySelectorAll('.list');

  var items = list.querySelectorAll('.list-item');
#+END_SRC

还可以直接用包含选择器

#+BEGIN_SRC js
  var items = document.querySelectorAll('.list .list-item');
#+END_SRC

items是一组元素


#+BEGIN_SRC js
  items.length = 1;
  console.log(items.length); //3 
#+END_SRC

这一组元素的length属性不能写，说明这一组元素不是一个数组。它称之为 *类数组*

错误的写法


#+BEGIN_SRC js
  // items.style.backgroundColor = 'rgb(110,232,173)';
#+END_SRC

*** 通过元素的标签名获取一组元素
元素对象.getElementsByTagName('标签名');

#+BEGIN_SRC js
  var spans = document.getElementsByTagName('span');
#+END_SRC

获取list2里的span

#+BEGIN_SRC js
  var list2 = document.querySelector('.list2');
  var list2Span = list2.getElementsByTagName('span');
#+END_SRC

*** 区别
getElementsByTagName 是动态获取元素

querySelectorAll 一开始创建完空间就不会再改变


#+BEGIN_SRC js
  var list = document.querySelector('.list');

  var listSpan = document.getElementsByTagName('span');

  var spans = document.querySelectorAll('.list span');

  document.onclick = function (){
  //console.log(spans); // 3个
  //console.log(listSpan); // 3个
  
  var str = '';
  for(var i=0; i<3 ;i++){
    str +='<span>'+(i*10)+'</span>';
  }
  list,innerHTML += str; // 先清空之前的然后添加
  // console.log(spans); // 3个
  // console.log(listSpan); //6个
};
#+END_SRC

** 操作一组元素


   #+BEGIN_SRC html
       <div class="btns">
         <span class="btn-item">1</span>
         <span class="btn-item">2</span>
         <span class="btn-item">3</span>
         <span class="btn-item">4</span>
         <span class="btn-item">5</span>
       </div>
   #+END_SRC


   #+BEGIN_SRC js
     var btns = document.querySelectorAll('.btns .btn-item');

     for( var i=0,len = btns.length ; i<len;i++){
         btns[i].style.backgroundColor = 'rgb(93,226,158)';
     }
   #+END_SRC

   错误的作法


   #+BEGIN_SRC js
     // for(var i=0,len =btns.length;i<len;i++){
     //     btns[i].onclick = function (){
     //         console.log(btns[i].innerHTML); // i 是循环之后的结果 就是length // undefined
     //     };
     // }
   #+END_SRC

** 关键字 this
this：是JS的一个关键字，是预先定义好的这个变量，这个变量里的值是不固定的，会随着
执行环境(上下文)的改变而变化

	1.this在函数外也就是 全局 下，代表 window

       2.在函数内, this 不一定是什么。

          - 元素对象.事件 = 事件处理函数。那么 事件处理函数 里的this 就是触发
            这个事件的 那个 元素对象


          #+BEGIN_SRC js
                document.onclick = function (){
                  console.log(this);// documnet
                };

                window.onclick = function (){
                  console.log(this);
                };
          #+END_SRC

** 给对象添加自定义属性

   比如input 自带 type value name class 这些属性， 但是除了自带属性

   还可以定义属性

   元素对象.自定义属性名 = 值


   #+BEGIN_SRC html
       <div class="btns">
         <button>按钮0</button>
         <button>按钮1</button>
         <button>按钮2</button>
         <button>按钮3</button>
         <button>按钮4</button>
       </div>
   #+END_SRC


   #+BEGIN_SRC js
     var btns = document.querySelectorAll('.btns button');

     for(var i=0,len = btns.length; i<len; i++){
         btns[i].a = i; // 给每个元素添加自定义属性

         btns[i].onclick = function (){
             alert(this.a);
         };
     }
   #+END_SRC
** 模拟单选框


   #+BEGIN_SRC html
       <div class="box">
         请选择：
         <span>男</span>
         <span>女</span>
         <span>保密</span>
       </div>
   #+END_SRC


   #+BEGIN_SRC css

         .box {
           width: 300px;
           height: 50px;
           display: flex;
           justify-content: space-between;
           align-items: center;
           font-size: 20px;
         }
         span {
           width: 50px;
           height: 50px;
           border: 1px solid #000;
           border-radius: 50%;
           display: flex;
           justify-content: center;
           align-items: center;
           font-size: 14px;
           cursor: pointer;
         }
   #+END_SRC

*** 第一种: 清空上一个

    一开始没有上一个， 那么随便定义一个是上一个
                                                
    #+BEGIN_SRC js
      var items = document.querySelectorAll('.box span');

      var prev = item[0];

      for(var i = 0,len = items.length ; i<len; i++){
          item[i].onclick = function (){
              prev.style.backgroundColor = '';
              this.style.backgroundColor = 'rgb(226, 73, 114)';
              prev = this; // 点击谁谁就是上一个
          };
      }
    #+END_SRC
*** 第二种: 清空所有的，然后给当前点击的这个元素添加属性

    #+BEGIN_SRC js
      for(var i=0,len = items.length; i<len;i++){
          items[i].onclick = function (){
              for(var i = 0; i<len; i++){
                  item[i].style.backgroundColor = '';
              }
              this.style.backgroundColor = 'rgb(226, 73,114)';
          };
      }
    #+END_SRC
** 模拟单选框进阶

1.点击任意一个可以切换有背景颜色
2.点击任意一个让其它的背景颜色消失



#+BEGIN_SRC js
  var items = document.querySelectorAll('.box span');

  for(var i = 0, len = items.length; i<len; i++){
      items[i].selected = false; // 给每个元素添加一个控制的变量 true 代表选中 false 代表没选中
      items[i].onclick = function (){
          if(this.selected){//点谁就判断谁身上的selected属性
              this.style.background='';
          }else{
              for(var i = 0 ; i<len ; i++){
                  item[i].style.background = '';
                  item[i].selected = false ;
              }
              this.style.background ='rgb(226,73,114)';
          }
          this.selected = !this.selectedl
      };
  }
#+END_SRC

** 小结

    1.获取一组元素(类数组)

    2.for循环中函数里面不能使用那个i。

    3.this

    4.自定义属性

    5.清空所有，给当前添加 清除上一个给当前添加

* 20170913
** 选项卡
*** 选项卡的原理
    由一组元素去控制另外一组元素
*** [[D:\学习指南\2-javascript\20170913\选项卡的基本实现.html][选项卡的简单实现]]

    -1.获取所有的按钮和对应的内容
    -2.给所有的按钮添加点击事件
    -3.模拟单选


    #+BEGIN_SRC html
          <div class="container">
            <div class="btn-group">
              <div class="btn active">图片</div>
              <div class="btn">新闻</div>
              <div class="btn">热点</div>
            </div>

            <div class="item-con">
              <div class="item active">图片</div>
              <div class="item">新闻</div>
              <div class="item">热点</div>
            </div>
          </div>
    #+END_SRC


    #+BEGIN_SRC css
           ,*{
               box-sizing: border-box;
           }
           .container{
               width: 500px;
               height: 700px;
               display:flex;
               flex-direction: column;
           }
           .btn-group{
               width: 100%;
               height: 100px;
               display:flex;
               justify-content: space-around;
               flex-flow: row no-wrap;
               align-items:center;
           }
           .btn{
               flex:1;
               background-image: linear-gradient(orange 0,orange 100%,#fff 0);
               background-size:   0px 100%;
               background-repeat:no-repeat;
               text-align: center;
               line-height: 100px;
               vertical-align: middle;
               font-size: 32px;
               border: 1px solid #ccc;
               border-bottom: 0px;
               transition: 0.5s;
               cursor: pointer;
           }
           .item-con{
               width: 100%;
               flex:1;
               border: 1px solid #ccc;
           }
           .item{
               width: 100%;
               height: 100%;
               display: flex;
               font-size: 50px;
               justify-content:center;
               align-items:center;
               display:none;
               color: blue;
               tansition: 0.5s
               background: #000;
           }
           .btn:hover{
               background-size: 100% 100%;
               color: #fff;

         
           }
           .btn.active{
               background: linear-gradient(orange 0,orange 100px,#fff);
               color: #fff;
           }
           .item.active{
               background: #999;
               display:flex;
           }
    #+END_SRC

    第一种方案: 点击按钮清除上一个的样式

    #+BEGIN_SRC js
      var btns = document.querySelectorAll('.btn'); // 选取所有的控制组件btn
      var items = document.querySelectorAll('.btn'); // 选取所有的行为组件item

      var len = btns.length; // 获取btn的个数

      var prevIndex = 0; // 初始选中的索引值是第一个

      // console.log(btns,items,len); 检查选取是否出现错误
      
      for(var i = 0; i < len ; i++){
      btn[i].index = i; // 初始化btn类数组的索引值
      btns[i].onclick = function (){
      	btns[prev].classList.remove('active'); //清除按钮上一个的激活样式
       	items[prev].classList.remove('active'); //清除内容上一个的激活样式
        	btns[this.index].classList.add('active'); //给当前按钮添加激活样式
             items[this.index].classList.add('active'); //给当前激活的内容区添加样式
             prev = this.index; //点击的按钮设置为上一个
};
}
    #+END_SRC
第二种方案: 清除全部

#+begin_src js
  var btns = document.querySelectorAll('.btn');  // 选取所有的控制组件btn
  var items = document.querySelectorAll('.btn'); // 选取所有的行为组件item

  var len = btns.length; // 获取btn的个数

  for(var i=0; i<len; i++){
      btn[i].index = i;
      btns[i].onclick = function (){
  	for(var i = 0 ;i<len; i++){
        	btns[i].classList.remove('active'); //清除按钮的所有激活样式
        	items[i].classList.remove('active'); // 清除内容的所有激活样式
}
	this.classList.add('active'); //给当前按钮激活的添加样式
	this.classList.add('active'); // 给当前内容激活的添加样式
  };
  }
#+end_src

*** 选项卡拓展:[[D:\学习指南\2-javascript\20170913\0913img\index.html][图片切换]]
#+begin_src html
    <div class="container">
      <div class="img-box">
        <a class="item active" href="javascript:;"><img alt="" src="./img/1.jpg"/></a>
        <a class="item" href="javascript:;"><img alt="" src="./img/2.jpg"/></a>
        <a class="item" href="javascript:;"><img alt="" src="./img/3.jpg"/></a>
        <a class="item" href="javascript:;"><img alt="" src="./img/4.jpg"/></a>
        <a class="item" href="javascript:;"><img alt="" src="./img/5.jpg"/></a>
      </div>

      <div class="circle-group">
        <span class="circle active"></span>
        <span class="circle"></span>
        <span class="circle"></span>
        <span class="circle"></span>
        <span class="circle"></span>
      </div>
    </div>
#+end_src

#+begin_src css
     body{
         margin: 0px;
     }
     .container{
         width: 100%;
         height: 900px;
         overflow:hidden;
         position: relative;
     }
     img{
         width: 100%;
         margin-top: -50px;
         vertical-align: top;
     }
     .img-box{

         width: 100%;
         height: 100%;
     }
     .item{
         width: 100%;
         position: absolute;
         left: 0px;
         top: 0px;
         opacity:0;
     }
     .circle-group{
         display: flex;
         position:absolute;
         bottom: 0px;
         left: 0px;
         width: 100%;
         height: 60px;
         justify-content:center;
     }
     .circle{
         width: 40px;
         height: 40px;
         border-radius:50%;
         margin: 5px;
         background: blue;
         opacity: 0.4;
         with:w;
     }
     .item.active{
         opacity:1;
     }
     .circle.active{
         background:red;
         opacity:1;
     }
     .circle:hover{
         opacity:1;
     }
#+end_src

#+begin_src js
var items = document.querySelectorAll('.item'); //获取所有图片的父级a标签
var circle = document.querySelectorAll('.circle'); // 获取所有控制按钮

var len = circle.length; //获取按钮的个数
console.log(item,circle,len); //验证获取的正确性

for(var i = 0; i < len ;i ++){
	circle[i].index =i; //定义按钮的自定义属性 ――索引值
    	circle[i].onclick = function (){
        for(i=0; i<len; i++){
        circle[i].classList.remove('active'); // 清空所有按钮的激活样式
        items[i].classList.remove('active');// 恢复所有图片的不透明度为0
        }
        this.classList.add('active'); //给当前激活的按钮添加样式
        items[this.index].classList.add('active'); // 让图片的不透明度为1
};
}
#+end_src
* 20170914
** qq列表
* 20170915
** 幻灯片
   mvc 思想

   -m： model 模型(数据)

   -v: view 视图(html+css)

   -c: control 控制器(JS脚本)

   #+begin_src html
   <div class="slide-container">
    <div class="slides"></div>
    <div class="navs"></div>
    <div class="prev"><</div>
    <div class="next">></div>
  </div>
   #+end_src

#+begin_src css
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
    a {
      text-decoration: none;
      color: #fff;
    }
    .slide-container {
      width: 720px;
      height: 450px;
      border: 4px solid #000;
      margin: 30px auto;
      position: relative;
    }
    .slides {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
    }
    .slider-item img {
      width: 100%;
      height: 100%;
      display: block;
    }
    .slider-item {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: opacity 0.4s linear;
    }
    .slider-item.active {
      opacity: 1;
    }
    .navs {
      position: absolute;
      left: 50%;
      bottom: 5%;
      transform: translateX(-50%);
      text-align: center;
    }
    .nav-item {
      display: inline-block;
      width: 30px;
      height: 30px;
      transform: scale(0.5);
      background-color: rgb(71, 173, 221);
      border-radius: 50%;
      position: relative;
    }
    .nav-item .s-img {
      position: absolute;
      width: 100%;
      transform: translateX(50%) scale(4);
      left: -50%;
      top: -180%;
      display: none;
    }
    .nav-item:hover .s-img {
      display: block;
    }
    .nav-item.active {
      background-color: rgb(228, 50, 141);
    }
    .prev,
    .next {
      width: 40px;
      height: 80px;
      background-color: rgba(0, 0, 0, 0.2);
      text-align: center;
      line-height: 80px;
      font-size: 40px;
      color: #fff;
      font-weight: bold;
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      cursor: pointer;
    }
    .prev {
      left: 0;
    }
    .prev:hover,
    .next:hover {
      background-color: rgba(0, 0, 0, 0.5);
    }
#+end_src
#+begin_src js
//存储数据
var imgData = [
'./img/1.jpg',
'./img/2.jpg',
'./img/3.jpg',
'./img/4.jpg',
'./img/5.jpg'
];
var len = imgDate.length; //获取储存数据数组的长度

CreatBannerHtml(); //使用数据生成结构

function CreatBannerHtml(){
	var slides = document.querySelector('.slides'); //获取幻灯片的容器
    	var navs = document.querySelector('.navs'); //选定控制按钮的容器
	var imgStr = '',navStr='';   // 将要储存幻灯片和控制按钮的HTML的内存中的容器

 	for(var i=0; i<len; i++){
	var img = imgData[i]; //遍历每一个图片
	imgStr +=`<a href = "javascript:;" class = "slider-item">
    				<img src = "${img}">
                    	</a>`; //把每张幻灯片存到内存中
       navStr +=`<span class="nav-item"><img src = "${img}" class="s-img"></span>`;
}  //每个控制按钮存到内存中

	slides.innerHTML = imgStr; //把内存中的数据 写到HTML中
    	navs.innerHTML = navStr;
//--------------------------------------------------------------------------------------
       //处理用户和浏览器之间的交互
var slideItems = document.querySelectorAll('.slider-item'); //选中所有的幻灯片
var navItems = document.querySelectorAll('.nav-item');

var currentIndex = 0;

//初始化操作
tabSlider();

function tabSlider(){
	for(var i=0; i<len ;i++){
    slideItems[i].classList.remove('active');
    navItems[i].classList.remove('active');
}
slideItems[currentIndex].classList.add('active');
navItems[currentIndex].classList.add('active');
}

//给每个导航栏按钮添加交互
for(var i=0; i<len; i++){
navItems[i].index = i;
navItems[i].onclick = functin (){
currentIndex = this.index;
tabSlider();
};
}

var prevBtn = document.querySelector('.prev'); //获取上一个按钮

prevBtn.onclick = function (){ // 点击切换上一个
	currentIndex--;
  	if(currentIndex<0){
	currentIndex = len -1;
}
tabSlider();
};

var nextBtn = document.querySelector('.next');

nextBtn.onclick = function (){
	currentIndex++;
    	if(currentIndex > len-1){
        current = 0;
}
tabSlider();
};
#+end_src 
** qq音乐列表
   1.隔行变色

   2.鼠标的hover效果

   3.鼠标点击的选中效果

   4.判断选中过个，然后让全选选中或者未选中

   5.点击全选按钮，可以选中所有或者取消所有的选中

#+begin_src html
		<div class="wrap">
			<div class="baidu">
				<ul id="list">
					<li>
						<div></div>
						<span>泡沫</span>
						<span>邓紫棋</span>
					</li>
					<li>
						<div></div>
						<span>说爱你</span>
						<span>蔡依林</span>
					</li>
					<li>
						<div></div>
						<span>稻香</span>
						<span>周杰伦</span>
					</li>
					<li>
						<div></div>
						<span>我的梦</span>
						<span>张靓颖</span>
					</li>
					<li>
						<div></div>
						<span>怎么说我不爱你</span>
						<span>萧敬腾</span>
					</li>
					<li>
						<div></div>
						<span>无处安放</span>
						<span>白若溪</span>
					</li>
				</ul>
				<div class="select">
					<span class="selectAll"><span class="select-status"></span><span class="text">全选</span></span>
					<div class="others">
						<span><em></em>收藏</span>
						<span><em></em>添加</span>
						<span><em></em>删除</span>
					</div>
				</div>
			</div>
		</div>
#+end_src

#+begin_src css
			body,
			ul,
			li {
				margin: 0;
				padding: 0;
				list-style: none;
			}
			#list li.even {
				background: rgba(225,86,113,.3);
			}
			#list li.hover {
				background: rgba(225,86,113,.5);
				color: #fff;
			}
			#list li.checked {
				background: rgba(225,86,113,.8);
				color: #fff;
			}
#+end_src

#+begin_src js

    var listItems = document.querySelectorAll('#list li'); // 列表的每一项

    var selectedAllBtn = document.querySelectorAll('.selectAll'); //全选按钮

    var itemStatus = document.querySelectorAll('#list li div');  //每一项的选中状态

    var selectedAllStatus = document.querySelector('.select-status');//全选按钮的状态

    var len = listItems.length,num = 0; // 列表项的个数

    for(var i=0; i<len; i++){
    //把每个列表项所有的背景颜色类名保存到自己的自定义属性身上
      listItems[i].bgColor = listItems[i].className = i%2 ? 'even' : '';
  //hover效果
          listItems[i].onmousover = function(){
          this.className = this.checked ？ 'checked' : 'hover';
      };
      listItems[i].onmousover = function (){
          this.className = this.checked ? 'checked' : 'this.color';
      };
          listItems[i].checked = false;
         listItems[i].onclick = function (){
         var status = this.querySelector('div');
         if(!this.check){
           statuts.innerHTML = 'o';
           this.className='checked';
           num++;
         }else{
           staus.innerHTML ='';
           this.className = this.color;
           num--;
          }
         this.selected = !this.selected;

         selectedAllStatus.innerHTML = num === len? 'o' : '';
         };
  }

  //全选按钮功能

  selectedAllBtn.onclick = function (){
  	if(num<len){
    		num = len;
             selectedAllStatus.innerHTML = 'o';
    	}else{
        num = 0;
        selectedAllStatus.inneHTML ='';
	}
    for(var i=0; i<len; i++){
    var status = listItems[i].querySelector('div');
    listItems[i].checked = num === len? true ： false;
    listItems[i].className = num === len ? check : listItems[i].color;
    status.innerHTML = num === len ? 'o' : '';
}
  };

#+end_src
* 20170917
** JS中的数据类型
***   基本数据类型

   -1.Undefined
   
   -2.Null
   
   -3.Number
   
   -4.Boolean
   
   -5.String

   -6.symbol

***   引用数据类型
   
    object(对象)

    - {}

    - DOM元素

    - []

    - function

     - js里除了基本数据类型，剩下的都是对象

使用typeof 要判断的数据 来区分数据类型

** 基本数据类型和引用数据类型的区别

var arr1 = [1,2]

var arr2 = arr1;  //引用数据类型复制的不是数据而是引用

arr1[0] = 10;

console.log(arr1); // [10,2]
console.log(arr2); //[10,2]

** 如何判断某个数据是不是数字

var a = 1;

if(typeof a === 'number'){
console.log('Is a number');
}

** undefined

  undefined 类型，只有一个值就是 undefined, 代表未定义。
  -如果变量声明但是没有被初始化那么储存的就是undefined
  -如果一个对象的属性名不存在，然后你去访问他结果就是undefined
  -一个函数，如果没有返回值，那么执行之后的结果是undefined

   var a;
   console.log(a); //undefined
   console.log(window.abc); // undefined
   var arr1 = [1,2,3]
   console.log(arr) // undefined
**  Null 类型
   只有一个值，就是null，代表空。空对象指针

   undefined 实际上是派生自 null,所以在比较值的时候是相等的

   
   console.log(typeof null); // 'object'

   返回'object'是js的历史遗留bug
   // 000 object标记位正好是低三位都是0 而null是机器码NULL而大部分机器码
是(0x00) 加上对象标记还是0,最终体现的类型是object

判断一个数据是不是null 

var n = null;

if(n === null){
console.log('Is a null');
}
 
** 函数

  1 函数也是一种数据
  2 typeof 函数，返回的不是'object' 而是function
  -函数也是对象，但是他是一个可以执行的对象，所以很有必要和普通的对象做一个区分
 函数表达式，不能再声明以前去使用

判断是否是个函数

var fn = function ffn(){
console.log(ffn);
//这个函数名字，只能在这个函数内部可以使用
}

** 对象类型的数据结构
对象类型的数据结构又称为字典类型的数据结果，和数据非常类似，但是不同于数组的是，
数组的key只能是从0开始的数字，而对象数据结构的key可以是任意的字符串

定一个对象使用{},对象主要包括 属性 和 方法 ，每个属性或者方法都由 键值对(key 和 value)
组成

自定义一个对象

var obj1 = {};
var obj2={

a:1,
'abc':[1,2,3],
'b-2':'str',
fn1:function(){alert(1)},
fn2(){alert(2)}
};

调用对象里面的方法

obj2.fn1();

obj2.fn2();

obj2.a;

obj['b-2'];

数组是特殊的对象

var obj3 = {

'0':'a'

'1':'b'

'2':'c'

'3':'d'

length:4

};

DOM元素也是对象

<div class="box"></div>

var div = {

tagName: 'div',

types:{

class:'box'

},

innerHTML:'123'

};

** js数据类型转换

Js 里面进行数据类型转换的时候只能转换成以下三种

-number (数字)
-String (字符串)
- Boolean (布尔值)

** 数字类型

   整数(正整数 和 负整数)

   浮点数(浮点数)

   NaN:

 not a number 不是一个数字 它的对象是数字 并不是任何非数字类型的值都会等于NaN，
只有在算术运算或数据类型转换出错时是NaN

非数字字符串转为数字类型时返回NaN，按理说字符串不是数字类型用isNaN() 应该返回false
的却返回true，Number.isNaN()纠正了isNaN的bug 全局方法isNaN() 会先将参数转为Numer、
类型，在判断是否为NaN，所以在类型转换失败或运算错误时值为NaN，返回true，其他全为false
Number.isNaN()先判断参数类型，在参数为Number的前提下运算错误时值为NaN返回true，
其他全为false

   NaN在平时使用的时候，不会主动的取用，但是一定你某个结果是NaN了，那么只能说明
一件事 代码写错了

NaN 和 任何数值都不相等 包括它自己

NaN 和 任何数值运算，结果都是NaN

正无穷(Infinity)和负无穷(-Infinity)

超过最大值（1.7976931348623157e+308） Infinity

超过最小值（5e-324） -Infinity

小数计算不精确

浮点数.toFixed(要保留的小数位)这个方法会四舍五入

console.log(typeof NaN);  //'number'

console.log('a'*1); //NaN

1 Number(要转换的数据)

2 parseInt(要转换的数据[,如果是数字可以制定进制，默认值是10进制])

3 parseFloat(要转换的数据)

* 20170918
** 字符串
由0个或者多个字符组合的集合，并且放到一对单引号或者双引号或者反引号。

属性: length 代表字符串的长度。length属性只可以读取，不可以修改

字符串一旦创建不可以再修改

将其他数据类型转换成字符串的方法： 

-String(要转换的数据)
-要转换的数据.toString()
-undefined 和 null 不能使用这个方法

String转换对象
 
console.log(String({a:1,b:2})); // [object,object]

-1.[object Object] {}相当于new Object(),定义一个对象的实例 

-2.toString()方法默认返回[object objectname] 

-3.小写的是方法返回的值的格式中默认的 大些的是对象的名字Object

函数则返回函数

数组则返回数组

undefined 和 null 没有这个方法
var str1 = 'abc';

str1 += 'd'

console.log(str1); // 'abcd'

toString()  和 String() 的区别

String的工作原理: 

值有toString()的方法则用toString()的方法

没有toString()的方法的 null则返回null undefined则返回undefined

//-----------------------------------------------------------------------------

String(); String是JS系统提供的内置函数

console.log(String(undefined));  // 'undefined'

console.log(String(null));  //'null'

直接去调用某个方法进行转换的成为显式类型转换

隐式类型转换 JS引擎自动做的事情

console.log('123'*1); // 123 最快的把数字字符串转换为数字

** 布尔值
-true 真
-false 假

数值 除了0和NaN其它的转布尔值 都是true

字符串 除了空字符串转布尔值是假的其它都是真的

console.log(Boolean('')) // false

console.log(Boolean('  '));//true

所有的对象都是真的

取反的返回值(结果) 一定是个布尔值

[]==![]    会优先向数字类型转换

*** 逻辑运算符

逻辑与 &&
逻辑或 ||
逻辑非！ 返回值一定是一个布尔值

当在赋值的时候 

逻辑与 会一直向后找 直到找到第一个转布尔值为false的值, 如果没有就是最后一个值

逻辑或 会一直向后找，直到找到第一个转布尔值为true的值，如果没有就返回最后一个

** 类数组

可以使用索引取到对应的值， 也具有length 属性， 但是length 属性只可以读取不可以修改

var str = 'abcd'

console.log(str[0]);  //a
console.log(str[1]);   //b

* 20170920
** 函数
可以对任意多天语句进行封装，代表一个功能的整体。

函数的分类：

-函数声明

-函数表达式

-匿名函数

函数是一种特殊格式的对象，所以函数也是一种数据。

一个完整的函数定义：

关键字 function fn 函数名(参数1,参数2...){

一个完整的函数的定义：

关键字 function fn函数名(参数1,参数2...){

代码1

代码2

return；(返回值)
}

}

** 函数表达式

var fn = function (){
// fn为函数表达式的一个引用

后面加个()就可以执行

console.log(1);

};

fn(); //函数表达式(匿名函数)
 
function(){/**code**/}(); //SyntaxError 语法错误
*报错* 因为在解析器解析全局的function或者function关键字的时候 默认是认为function
声明，而不是function表达式，如果你不显示告诉编译器，他会默认会声明成一个缺少名字
的function，并且抛出一个语法错误信息，因为function声明需要一个名字



函数表达式(匿名函数)

(
function (){
console.log(2);
}
)(); //函数表达式的自执行

(
function fn(){
console.log(2);
}
);  //函数表达式的自执行

// 因为JS 里圆括号()里面不能包含语句 所以在这一点上，解析器在解析function关键字的时候
会将相应的代码解析成function表达式而不是function声明

(function (){/*code*/}());

(function(){/**code**/})();
fn();

匿名函数不能执行 主要原因 是 全局下 function被解析成了 关键字 而不是表达式
所以 为了消除歧义 在最外层加分组操作符 &&
!function (){
console.log(2);
}();

~function (){
console.log(2);
}();

+function (){
console.log(2);
}

function add(a,b){
// a b 叫做 形参 ，形式上的参数，可有可无
console.log(a);
console.log(b);
console.log(a+b);
}
add(1,2);
add();
add(3,4);
//实参和形参是一一对应的。

** arguments
函数内部存在的一个对象，是一个类数组，

它的作用是： 保存实参的集合
#+begin_src js
function add(){
var arg = arguments, num = 0;
for(var i=0;i<arg.length; i++){
num+=arg[i];
}
console.log(num);
}

add(1,2,3); // 6
add(4,5,6,7); // 22
#+end_src

** return

函数中的 return

这个return 你写不写，他都在那里，静静的看着你。

1 作为函数的返回值，后面是什么就返回什么。

2 凡是return后面的代码，都不会再继续执行。

#+begin_src js
function fn1(){

a++  //2
console.log(++a);
return --a;
console.log(a+=2);
}
console.log(fn1()); // 3 2
console.log(a); //2 
#+end_src

** [[D:\学习指南\2-javascript\20170920\06-传参案例.html][传参案例]]

#+begin_src js
var colorData = ['red','yellow','green'];

setColor('.demo1');
setColor('.demo2');
setColor('.demo3');

function setColor(ele){

var btns = document.querySelectorAll(`${ele} .btn`);

for(var i=0; i<btns.length;i++){
btns[i].off = true;
btns[i].index = i;
btns[i].onclick = function (){
this.style.backgroundColor = this.off ? colorDate[this.index]: '';
this.off = !this.off;
}
}

}
#+end_src
** 练习1
1.封装一个函数，这个函数的名字叫做push
2.这个函数的参数，第一个是一个数组，第二个以后是任意的数据
3.调用这个函数，那么把第二个以后的所有参数，依次放到第一个参数也就是那个数组的最后一个
位置。
4.这个函数返回值，是放入这些数据之后数组的长度
#+begin_src js
function push(arr){

var arg = arguments;

for(var i=1; i<arg.length; i++){
	arr[arr.length] = arg[i];
}
return arr.length;
}

var arr = [i];

console.log(push(arr,2,3));
console.log(arr;
#+end_src
* 20170921
** pop
1 封装一个函数，名字叫做 pop

2 pop函数的参数是唯一的数组

3 调用pop函数，删除数组中最后一个数据

4 如果这个数组是空，那么调用这个函数，返回值是undefined

5 如果不是空数组返回值为被删除的数据

var arr = [1,2,3];

function pop(arr){

	var len = arr.length, last = arr[len-1];
      if(!len) 

}

* 20170925
** getComputedStyle()

浏览器实际显示元素的样式成为计算后的样式

使用getComputedStyle来获取对应的样式
#+begin_src css
.box{
position:absolute;
left:100px;
top:100px;
width:200px;
height:200px;
border: 2px solid #000;
background: rgb(65,164,227);
transform: rotate(45deg);
}
#+end_src
#+begin_src js
console.log(getComputedStyle(box).transform);
    // matrix(0.707107, 0.707107, -0.707107, 0.707107, 0, 0)
//获取的是一个矩阵
#+end_src
** css函数
1 封装一个函数名字叫做css

2 这个函数的参数有3个，对应: 元素、元素的样式、样式对应的值

3 如果只传前2个参数， 那么是获取元素的样式，如果传了3个参数，那么是设置这个元素对应
的样式。

#+begin_src js
function css(ele,attr,val){
	if(typeof val === 'undefined'){
        return parseFloat(getComputedStyle(ele)[attr]);
}
if(attr === 'opacity'){
	ele.style.opacity = val;
}else{
	ele.style[attr] = val + 'px';
}
}

var box = document,querySelector('.box');

//console.log(css(box,'width'));
#+end_src

** for...in

for...in 循环是用来遍历对象的

for(var key in obj){

//key 代表这个obj对象的每个 属性名


//对象每个数据对应的值: obj[key]

}

// in 操作符，可以知道某个属性是否在这个对象中

** 矩阵的计算

2d变换之后的坐标

x0 = ax + cy + e;

y0 = bx + dy + f;

位移的公式

x0 = x + dx;
y0 = y + dy;

缩放的公式(s代表缩放的倍数)

x0 = s*x;
y0 = s*y;

顺时针旋转
x0 = cos(angle) * x - sin(angle) * y;
y0 = cos(angle) * y + sin(angle) * x;

逆时针
x0 = cos(angle)*x + sin(angle)*y;
y0 = cos(angle)*y - sin(angle)*x;

向x和y轴方向分别位移100

x0 = x + 100；
y0 = y + 100;

** switch
switch 用于多个条件判断，使用case语句进行配合

每个case语句之后需要一个break 来终止后续条件判断，如果不写，那么凡是条件成立的
语句都会执行。直到遇到一个break为止

如果每个case 语句都不成立，那么会走default 后面的代码

case 后面使用的是严格比较

#+begin_src js
var day = new Date().getDay();

console.log(typeof day);

switch(day){
	case 1;
    		alert('星期一');
            break;
       case 2;
       	alert('星期二');
       	break;
        case 3;
        	alert('星期三');
            break;
        default: 
        	alert('不知道星期几');

}
#+end_src
** while
while(条件判断){
	//循环体
}

凡是终止条件不确定的时候， 多用while循环

** 递归
递归一定要有一个终止的条件，否则就是死循环

凡是循环搞不定的事情，递归一定能搞定。

求阶乘

#+begin_src js

function fn(n){
	if(n ===1){
    return 1;
	}
    return n*fn(n-1);
}
#+end_src
* 20170926
** 定时器的概念
定时器分为两种: 
-重复型定时器 以指定的时间间隔，做同一件事，只要不停止 就一直做下去。
-延迟型定时器: 在指定的时间间隔后，做一件事，只做一次。

** 重复型定时器
   
   setInterval(fn, delay, arg1, arg2...);

   -fn: 要做的事情
   
   -delay: 时间间隔(单位: ms) 1s ===1000ms

   -arg1,arg2... ：如果fn 有参数， 那么这些代表fn 的参数

   返回值: 当前定时器的编号(不同的浏览器这个编号是不一样的)

   html5的最新规范，规定了定时器最短时间间隔是4ms

#+begin_src js
setInterval(function(){

console.log(1);

},1000);
#+end_src

#+begin_src js
function fn(n){

}

var t1 = setInterval(fn,1000,1);
var t2 = setInterval('fn(1)',1000);
var t3 = setInterval('fn(1)',1000);
var t4 = setInterval('fn(1)',1000);

console.log(t1,t2,t3,t4);
#+end_src

** 延迟型定时器

setTimeout(fn,delay,arg1,arg2);

参数和setInterval是一样的
返回值也是当前这个定时器的编号

#+begin_src js
function fn(){

alert('hello world');
}

setTimeout(fn,3000);
#+end_src

#+begin_src js
(function fn(){
	console.log('xxxx');
	console.log(setTimeout(fn,1000));
})();
#+end_src
** 清除定时器
-clearInterval (要清除的定时器的编号)
-clearTimeout(要清除的定时器的编号)

这两个方法的参数， 无论你给它们什么样的数据类型，都不会报错

#+begin_src js
var n=1;
var t1 = setInterval(function(){
	console.log(n++);

	if(n>50){
    clearTimeout(t1);
}
},50);
#+end_src

#+begin_src js
var t2 = setTimeout(function(){
	alert('hello');
},3000);

document.onclick = function(){
	clearTimeout(t2);
};
#+end_src

#+begin_src js
clearTimeout(null);
clearTimeout(undefined);
clearTimeout(function(){});
#+end_src

* 20170927
** 时间对象

时间对象: JS里的时间对象是基于1970年1月1日00:00:00(格林尼治时间)

创建时间对象: new Date();

单独使用 new Date() 那么代表当前你的计算机的系统时间

这个时间，获取的是这行代码执行时候的时间，不会自动更新

** 时间对象的分解

var now = new Date();

-now.getFullYear();获取年份

-now.getMonth(); 获取月份， 月份的范围是0-11,0代表1月，11月代表12月，所以想等到当前的
月份，需要+1

-now.getDate(); 获取到的是now这个对象里面的时间是几号

-now.getDay(); 获取星期，0 代表星期日

-now.getHours(); 获取小时

-now.getMinutes(); 获取分钟

-now.getSeconds(); 获取秒钟

-now.getTime(); timestamp 时间戳 获取的是1970年1月1日00:00:00到现在的毫秒


>获取timestamp的简写形式: Date.now();

** 简单的数字时钟

#+begin_src js
<div class="container">
	<span class="time">10:23:50</span>
 	<span class="date">2017年9月27日</span>
</div>
var time = document.querySelector('.time');
var date = document.querySelector('.date');

clock();

setInterval(clock,500);

function clock(){

var now = new Date();
var y = now.getFullYear();
var m = now.getMonth()+1;
var d = now.getDate();
var hours = now.getHours();
var mins = now.getMinutes();
var secs = now.getSeconds();

time.innerHTML = add0(hours) + ':' + add0(mins) + ':' + add0(secs);
date.innerHTML = y + '年' + m + '月' + d + '号';

}

function add0(n){
	return n<10 ? '0' + n : '' + n;
}

#+end_src
* 20170928
** 获取元素到定位父级的距离
定位父级： 就是元素相对于父级去定位的那个元素

获取元素到定位父级的距离：

-ele.offsetLet 获取的left值
-ele.offsetTop获取的top值

> 上面这两个方法， 不需要元素一定是定位的。

#+begin_src html
<div class="wrap">
    <div class="box"></div>
</div>
#+end_src
#+begin_src js
var box = document.querySelector('.box');

console.log(box.offsetLeft);
console.log(box.offsetTop);
#+end_src
** 获取元素的宽度

#+begin_src html
<div class="box"></div>
#+end_src

#+begin_src css
.box{
	position: absolute;
    	left: 100px;
       top: 50px;
       width: 300px;
       height:300px;
       border: 10px solid #000;
       padding: 20px; 
       margin: 20px;
       background: red;
}
#+end_src

#+begin_src js
var box = document.querySelector('.box');

console.log(getComputedStyle(box).width);

console.log(box.offsetWidth);
console.log(box.clientWidth);
#+end_src

ele.offsetWidth / ele.offSetHeight

-获取元素边框(包括边框) 里的大小

ele.clientWidth / ele.clientHeight

-获取元素边框(不包括边框)里的大小

** getBoundingClientRect

#+begin_src html
<div class="wrap">
    <div class="body">
        <div class="box"></div>
    </div>
</div>
#+end_src

#+begin_src css
.wrap{
width:500px;
height:300px;
border: 2px solid #000;
position: relative;
left: 200px;
top: 70px;
}
.body{
width: 80%;
height:60%;
position: absolute;
left:10px;
top:20px;
border: 2px solid blue;
}
.box{
width: 100px; 
height:100px;
position: absolute;
left: 80px;
top:60px;
background:red;
border: 2px solid #000;
}
#+end_src

ele.getBoundingClientrect();
-获取元素到屏幕左侧和伤侧(到body)的绝对位置
-获取元素的offsetWidth和offsetHeight

#+begin_src js
var box = document.querySelector('.box');

console.log(box.getBoundingClientRect());
#+end_src
** 让一个div匀速运动

** 动画帧和清除动画帧
** 更好的让一个div运动
** tween运动形式的应用

* 20171013

** new Array

创建数组:

字面量表示法 : var arr = [];

实例化数组: var arr = new Array();

#+begin_src js
var arr1 = [1,2,3];

var arr2 = new Array(1,2,3);

console.log(arr1);
console.log(arr2);

#+end_src

当 new Array()的参数只有一个,并且这个参数是一个数字的时候，那么代表创建一个长度为
这个数字的空数组

#+begin_src js
var arr = new Array(5);

console.log(arr); //[empty *5];
#+end_src

#+begin_src js
[
[0,0,0],[0,0,0],[0,0,0]
]

function creatMap(x,y){

	var arr = new Array(x);

    for(var i=0;i<arr.length;i++){
    arr[i] = new Array(y);

    arr[i].fill(0);
}

return arr;

}
#+end_src

** array.isArray

可以判断这个数据是不是数组，如果是那么就返回true,否则就是false

#+begin_src js
function test(){
	var arr = [];
    var obj = {};
console.log(Array.isArray(arr));
console.log(Array.isArray(arguments));
console.log(Array.isArray(obj));
}

test();
#+end_src

** Array.from(类数组)

把类数组转化为数组

#+begin_src js
var divs = document.querySelectorAll('div');

console.log(Array.isArray(divs));

divs = Array.from(divs);

console.log(divs);

console.log(divs);

console.log(Array.isArray(divs));

divs.length--;

console.log(divs);

var str = 'abcd';

console.log(Array.from(str));
#+end_src

** arr.indexOf()
   :PROPERTIES:
   :ORDERED:  t
   :END:

#+begin_src js
var arr = [1,2,3];

console.log(arr.indexOf(2)); //1
console.log(arr.indexOf(10)); //-1
#+end_src

** arr.push(element1,...,elementN);

push() 方法将一个或多个元素添加到数组的末尾，并返回数组的新长度。

#+begin_src js
var arr = ['a'];

console.log(arr.push(1,2,3)); //['a',1,2,3]

console.log(arr); // 4
#+end_src

** arr.pop();

pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。

#+begin_src js
var arr = [1,2,3];

console.log(arr.pop()); //3
#+end_src

** arr.shift()

shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。

#+begin_src js
var arr = [1,2,3];

console.log(arr.shift()); //1
console。log(arr);//[2,3]

#+end_src

** arr.unshift(element,...,elementN);

unshift() 方法将一个或到哦个元素添加到数组的开头，并返回新数组的长度。

#+begin_src js
var arr = [];

arr.unshift(1,2,3);

console.log(arr); // [1,2,3]
#+end_src

** arr.splice(start,[deleCountt,item1,item2])

splice()方法通过删除现有元素和/或添加新元素更改一个数组的内容

start: 指定修改的开始位置(从0计数)。如果超出了数组的长度，则草丛数组末尾开始添加内容;
如果是负值,则表示从数组末尾开始的第几位(从1计数)。

deleteCount:整数 表示要移除的数组元素的个数。如果deletCount是0，则不移除元素。这种
情况下，至少应添加一个新元素。如果deleteCount大于start之后的元素的总数，则从start后
面的元素都将被删除(含第start位);

item1,item2,...要添加进数组的元素 从strat位置开始。如果不指定，则splice()将只删除数组元素

返回值是一个被删除元素的数组.

#+begin_src js
var arr = ['a','b','c'];

console.log(arr.splice(1,1)); //['b']

console.log(arr);
#+end_src

* o20171023
** DOM 操作表格
   通过 table.tHead 可以获取到表格头
   通过 table.tFood 可以获取到表格脚

   通过 tbody.rows[index] 获取到某个tbody里面的index行
   table.tbodies[0].rows 第一个tBody里面的所有的行
   table.tbodies[0].rows[0] 第一个tBody里面的第一行

   通过 row.cells[index] 获取到某一行里面的第index个单元格
   table.tbodies[0].rows[0].cells 获取到rows[0]的所有的单元格
   table.tbodies[0].rows[0].cesll[1]获取到rows[0]的所有单元格中的第二个


#+begin_src js
   var table = document.getELementById('table');
   console.log(table.thead);
   console.log(table.tFoot);
   console.log(table.tBodies[0].rows[0].cells[1]);
#+end_src

** DOM 创建表格
创建表格头 table。creatTHead(); 创建并返回被创建的thead元素，然后会自动插入table
#+begin_src js
var thead = table.creatTHead();
#+end_src

创建表格林 table.creatTBody(); 创建并返回被创建的tbody元素，然后会自动插入table

#+begin_src js
table.createTBody();
#+end_src

创建表格脚 table.createTFoot();创建并返回被创建的tfoot元素,然后会自动插入table

#+begin_src js
table.createTFoot();
#+end_src

通过tbody.insertCell(_pos_); 向tbody中指定位置添加一行tr,并返回这个元素
向tbody中指定位置添加一行tr,并返回这个元素

#+begin_src js
table.deleteThead(); //删除表格头
table.deleteTFoot();//删除表格脚
table.tNodes[_pos_].deleteRow(_pos_) //删除对应行的对应位置
#+end_src

** dom 获取表单元素

#+begin_src js
document.forms //获取到页面上所有的表单
forms.someInputName //获取到对应name的表单内部元素
var form1 = documnet.forms[0];
var text1 = form1.text1;
var submit1 = form1.submit1;

submit1.onclick = function(){
alert(text1,text2);
};
#+end_src

** DOM操作补充
快速获取 body document.body
快速获取 html document.documentElement
快速获取title document.title(可读可写)

#+begin_src js
var n=0;

setInterval(function(){
document.title = n++;
},50);
#+end_src

** html5 自定义属性

data-属性名="value" 代表html5的自定义属性

在js中 使用ele.dataset 可以获取到所有自定义属性的集合

如果data-后面是一个驼峰命名的，那么会把所有的字母都变成小写。

如果想使用驼峰命名，比如divEle，需要写成 data-div-ele

#+begin_src html
<div class="box" data-id="123" data-divEle="div" data-div-ele="box"></div>
#+end_src
#+begin_src js
console.log(box.dataset);
#+end_src

** DOM的属性操作


ele.getAttribute('属性名') 可以拿到元素身上属性对应的值
ele.setAttribute('属性名','属性值')


#+begin_src js
var img = document.getElementById('img');

console.log(img.getAttribute('src'));

img.setAttribute('class','img');
#+end_src
* 20171024
** BOM 的概念
BOM Browser Object Model 浏览器对象模型，它的核心是window对象，
同时window又是JS的顶层对象

** 提示框
1 alert() 弹出带确定按钮的确定框
2 prompt() 带文字提示和确定按钮的弹窗
3 confirm() 带确定和取消按钮的提示框

** 一个完整的url地址
https://www.xxx.com:80/a/b/c?a=1&b=2&c=3#abc

-https 成为协议 protocol
-www.xxx.com:80 称为host
-www.xxx.com 称为 hostname
-/a/b/c 称为路径
-?a=1&b=2&c=3 称为queryString查询字符串
-#abc 称为hash

window.location.href 可以获取到当前的url地址
window.location.href = url 也可以狮纸当前的url地址

** 用户代理信息
#+begin_src js
window.navigator.userAgent
#+end_src

判断是否是移动端

#+begin_src js
function isMb(){
	var ret = false;
    	var device = ['iPhone','Android','iPad'];
      var userAgent = window.navigator.userAgent;
      
      device.forEach(function(item,i){
      if(userAgent.indexOf(item) !== -1){
      ret = true;
      }

      return ret;
});

}
#+end_src

** queryString

window.location.search 可以获取到查询字符串，从?到#之间的内容，包括?不包括#
修改了 queryString 会刷新浏览器

#+begin_src js
var str1 ='http://www.xxx.com/aaa?a=1&b=2&c=3';
var str2 ='http://www.xxx.com/aaa?id=1';

===>{a:1,b:2,c:3}

var search = '?a=1&b=2&c=3'.substr(1);

//console.log(search);

var data ={};

if(search.indexOf('&')===-1){
	var temp = search.split('=');
    	data[temp[0]] = temp[1];
}else{
	var temp = search.split('&');
    //console.log(temp);
    for(var i=0; i<temp.length;i++){
    var item = temp[i].split('=');
    //console.log(item);
    data[item[0]] = item[1];
}
}

console.log(data);
#+end_src

** hash 锚地

#+begin_src html
  <a href="#div1">div1</a>
  <a href="#div2">div2</a>
  <a href="#div3">div3</a>
  <div id="div1">div1</div>
  <div id="div2">div2</div>
  <div id="div3">div3</div>
#+end_src

#+begin_src js
var divs = document.querySelectorAll('div');

[...divs].forEach(function(item,i){
	item.style,top = (i+1)*500+'px';
});
#+end_src

** hashchange事件

当hash改变的时候会触发hashchange时间

#+begin_src js
window.onhashchange =  function(){
	alert(window.location.hash);
};

Array.from(btns).forEach(function(item,i){
item.onclick = function(){
	window.location.hash = i;
};
});

window.onhashchange = function(){
var index = window.location.hash.substr(1);
//console.log(index);

	boxs.forEach(function(item,i){
    item.classList.remove('active');
	});
    boxs[index].classList.add('active');
};
#+end_src
* 20171026 事件
** 基本概念
1.事件: 事件是文档或者浏览器窗口中发生的 特定的 交互瞬间
2.事件名: 列如 click mouseover load...
3.事件处理函数:当执行某个事件发生的时候，这行的对应的函数称为事件处理函数,
如果元素发生了某件事，但是没有这件事对应的事件处理函数，那么这种情况成为事件流失。
4.事件流:事件流描述的是元素对象从页面中接受事件的顺序。事件发生时会在元素节点与跟节点
之间按照特定的顺序传播，路径所经过的所有节点都会收到该事件，这个传播过程既DOM事件

事件冒泡: 事件的传播是从最具体的事件目标到最不具体的事件目标。既从DOM树的叶子到根
事件捕获: 事件的传播是从最不特定的事件目标到最特定的事件目标。既从DOM树的根到叶子

** 标准事件
1.DOM标准采用捕获+冒泡。两种事件流都会触发DOM的所有对象,从document对象开始，也
在document对象结束。
DOM 标准规定事件流包括三个阶段: 事件捕获阶段、处于目标阶段和事件冒泡阶段。

- 事件捕获阶段: 实际目标(<div>) 在捕获阶段不会接收时间。也就是在捕获阶段，事件从
document到<html>再到<body>就停止了。

-事件处理阶段: 事件在<div>上发生并处理。但是时间处理会被看成是冒泡阶段的一部分。
-冒泡阶段: 事件又传播回文档。

** 浏览器的实现

1.所有现代浏览器都支持事件冒泡,但是现在高级的浏览器不遵守标准的规定，
从window开始传播，冒泡最终也到window对象
2.不推荐使用捕获
3.尽管DOM2级事件，标准规范明确规定事件捕获阶段不会涉及事件目标，但在
IE9、safari、chrome、firefox和Opera 9.5 以及更高版本都会在捕获阶段触发事件对象上
的时间。结果就是有两次机会在目标对象上面操作时间。

平时使用on+事件名的形式都是事件冒泡

** DOM事件级别

1. DOM 1级事件 on+事件名的形式
2. DOM 2级事件，采用事件监听的形式

#+begin_src js
const  btn = document.querySelector('.btn');
console.log(btn.onclick); //null

btn.onclick = function(){
alert(1);
};

btn.onclick = function(){
alert(2);
};

console.log(btn.onclick): //funtion(){alert(2)}

btn.onclick = null;
#+end_src

DOM 1级事件不能为通一个时间名添加多个时间处理函数

2.addEventListener

ele.addEventListener('事件名',事件处理函数，是否捕获);

是否捕获: 默认值是false，也就是不捕获

#+begin_src js
btn.addEventListener('click',click1);
btn.addEventListener('click',click2);

function click1(){
alert(1);
}
function click2(){
alert(2);
}

btn.onclick = null; 取消不了

#+end_src

ele.removeEventListener('事件名'，事件处理函数，是否捕获)

注意: 要和添加的事件处理函数一一对应

#+begin_src js
btn.removeEventListener('click',click1);

btn.addEventListener('click',function(){
alert('hello');
},true);

btn.removeEventListener('click',function(){
alert('hello');
},true);
#+end_src
无法移除对应的事件处理程序，原因就是函数长的虽然一样，但是不是同一个函数

** 事件对象

在触发DOM上的某个事件时，会产生一个事件对象event。这个对象中包含所有与事件有关的信息
包括导致事件的元素，事件的类型以及其他与特定事件相关的信息。

事件对象是事件处理函数的第一参数，不同的事件里面的属性是不一样的

#+begin_src js
var btn = document.getElementById('btn');

btn.addEventListener('click',function(e){
	console.log(e);
});
#+end_src
** 阻止事件对象

#+begin_src js
function (e){
	e.cancelBubble = true;
}
#+end_src

* 20171027 
** 系统事件
1 load 当加载完成时候触发
2 scroll 当滚动条滚动的时候触发
3 resize 当浏览器窗口大小发生变化的时候触发

#+begin_src js
var img = document.createElement('img');

img.id = 'img';
img.width = 800;

img.src = `./1.jpg`;

img.onload = function (){
	document.body.appendChild(img);
    	console.log(img.offsetHight):
};

window.addEventListener('scroll',function(e){
	console.log('scroll');
});

window.addEventListener('resize',function (e){
	console.log('resizep');
});

#+end_src

**  滚动距离

获取滚动条的滚动距离

#+begin_src js
documnet.documentElement.scrollTop / scrollLeft
#+end_src

#+begin_src js
window.addEventListener('scroll',function (e){
	console.log(documnet.documentElemenet.scrollTop);
});

documnet.addEventListener('click',function (e){
	document.documentElement.scrollTop  = 0;
});

//浏览器刷新让滚动条自动回到顶部的解决方法

;(function(){
	var timer = setInterval(function (){
    	if(!documnet.documnetElement.scrollTop){
        return clearInterval(timer);
	}
	document.documentElement.scrollTop = 0;
},50);
})();
#+end_src

** 回到顶部

#+begin_src js
var box = document.querySelector('.box');

window.addEventListener('scroll',function (e){
	if(document.documentElement.scrollTop >1000){
    box.style.display = 'block';
	}else{
	box.style.display = '';
}
});

box.addEventListener('click',function(e){
	documnet.documnetElement.scrollTop = 0;


var d = 3000;
var b = document.documentElement.scrollTop;
var c = 0 - b;
var starTime = Date.now();

(function move(){
	move.timer = window.requestAnimationFrame(move);
    	var t = Date.now() - startTime;
       if(t > d){
       t  = d;
       window.cancelAnimationFrame(move.timer);
       move.timer = null;
       }
       console.log(1);
       document.documentElement.srollTop = c / d*t+b;
})();

});
#+end_src

** 鼠标事件

1 click 
2 mouseover
3 mouseout

4 mouseenter 鼠标移入 (不冒泡)
5 mouseleave 鼠标移出 (不冒泡)

6 mousemove 鼠标抚摸事件
7 dbclick 鼠标双击事件(触发双击的前提一定会触发两次单击事件);

8 mousedoen 鼠标按下事件
9 mouseup 鼠标抬起事件

#+begin_src js
var box1 = document.querySelector('.box1');

var box2 = document.querySelecor('.box2');


//dbclick click 尽量避免在同一个元素身上同时使用下面这2个事件

box1.addEventListener('click',function(e){
	console.log('click');
});

box1.addEventListener('dbclick',function(e){
	console.log('dbclick');
});
#+end_src

click 事件触发的前提条件是，必须在同一个对象身上按下和抬起鼠标之后才会触发

#+begin_src js
box1.addEventListener('mousedown',function (e){
	console.log('mousedown');
});

box1.addEventListener('mouseup',function (e){
	console.log('mouseup');
});

//触发顺序 mouse down ==> mouseup ==> click
#+end_src

** 获取div的x,y

e.clientX / e.clientY ===> 鼠标在可视区的坐标不包括滚动距离

e.pageX / e.pageY ===> 鼠标在文档的坐标包括滚动距离

#+begin_src js
documnet.addEventListener('mousemove',function(e){
	var x = e.clientX, y= e.clientY;
    	console.log(x,y);
       console.log(x,y+document.documentElement.scrollTop);
       
});

document.addEventListener('mousemove',function(e){
	var x = e.pageX, y = e.pageY;
    	console.log(x,y);
});
#+end_src

** div跟随鼠标移动

想让一个元素跟随鼠标移动,那么别忘了给这个元素添加定位

#+begin_src js
var box = document.querySelector('.box');

document.addEventListener('mousemove',function(e){
	var x = e.pageX,y = e.pageY;

    	box.style.left = (x - box.offsetWidth / 2) + 'px';
       box.style.top = (y - box.offsetHeight / 2) + 'px'
});
#+end_src

** 阻止事件默认行为

DOM1级事件 可以使用 return false
DOM2级事件和DOM2级事件都可以使用e.preventDefault();

#+begin_src js
var btn = document.querySelector('a');

btn.onclick = function(e){
	//和冒泡都是 尽量写在处理函数的最开始
	e.preventDefault();
    	console.log('123');
              //  return false
};

var p = document.querySelector('p');

p.onselectstart = function(){
	console.log(1);
    	return false;
};
#+end_src

** 右键菜单

#+begin_src js
var menu =  document.querySelector('.menu');

document.addEventListener('contextmenu',function(e){
	e.preventDefault():
    	var x = e.pageX,y = e.pageY;
        // 必须先显示出来然后才能获取到尺寸

        if(window.innerWidth - x < menu.offsetWidth){
        x = window.innerWidth - menu.offsetWidth;
        }

        if(window.innerHeight - y < menu.offsetHeight){
        y = window.innerHeight - menu.offsetHeight;
}

	menu.style.left = x + 'px';
    	menu.style.top = y + 'px';

        menu.style.transform = 'scale(1)';
});

	document.addEventListener('click',function(e){
    menu.style.transform  = 'scale(0)';
});
#+end_src
* 20171030

** 拖拽的基本原理

1.当鼠标在当前元素身上按下的时候可以移动鼠标
2. 移动鼠标元素跟着鼠标位置进行移动
3.抬起鼠标元素停止在当前抬起鼠标的位置

#+begin_src js
var box = document.querySelector('.box');

box.addEventListener('mousdown',function(e){
//由于可能拖拽文字移动，所以首先要阻止这个默认行为

e.preventDefault();

//按下之后可以移动
box.addEventListener('mousemove',moveDiv);

box.addEventListener('mouserup',cancelMoveDiv);
});

function moveDiv(e){
	box.style.left = e.pageX + 'px';
    	box.style.top = e.pageY + 'px';
}

function cancelMoveDiv(){
	box.removeEventListener('mousemove',moveDiv);
    	box.removeEventListener('mouseup',cancelMoveDiv);
}


#+end_src

** 解决鼠标按下坐标点问题

使用ele.getBoundingClientRect() 获取到元素到body 的绝对位置

#+begin_src js
var box = document.querySelector('.box');

var dx;
var dy;

box.addEventListener('mousedown',function(e){
//由于可能拖拽文字移动,所以首先要阻止这个默认行动
	e.preventDefauly();

//求出鼠标按下那一刻, 距离元素左侧和右侧的那一段距离

	var rect = getRect(this);

	dx = e.pageX - rect.left;
    	dy = e.pageX - rect.top;
        
//按下之后可以移动

	box.addEventListener('mousemove',moveDiv);
    	box.addEventListener('mouseup',cancelMoveDiv);

	function moveDiv(e){
    	var x = e.pageX - dx;
       var y = e.pageY - dy;

       box.style.left = x + 'px';
       box.style.top = y + 'px';
}

	function cancelMoveDiv(){
    	box.removeEventListener('mousemove',moveDiv);
       box.removeEvnetListener('mouseup',cancelMoveDiv);
}

});

function getRect(ele){
	return ele.getBoundingClientRect();
}
#+end_src

** 解决快速拖拽

给document 添加move事件, 解决鼠标快速移动的问题,
如果是其他范围，要分情况来定

#+begin_src js
var box = document.querySelector('.box');

var dx,dy;

var rect = getRect(this){
dx = e.pageX - rect.left;
dy = e.pageY - rect.top;
}

box.addEventListener('mousedown',function(e){
//由于可能拖拽文字移动，所以首先要阻止这个默认行为
	e.preventDefault();
//按下之后可以移动
	document.addEventListener('mousemove',moveDiv);
    	document.addEventListener('mouseup',cancelMoveDiv);

        
});

function moveDiv(e){
var x = e.pageX - dx;
var y = e.pageY - dy;

box.style.left = x + 'px';
box.style.top = x + 'px';

}

function cancelMoveDiv(){
document.removeEventListener('mousemove',moveDiv);
document.removeEventListener('mouseup',cancelMoveDiv);
}
function getRect(ele){
	return ele.getBoundingClientRect()
}
#+end_src

** 使用一个变量来控制拖拽

设定一个变量默认是false,如果在元素身上按下了,
那么这个变量变为true,如果这个变量是true,那么可以执行拖拽操作,当鼠标抬起的时候
，把这个变量变为false,这样再移动鼠标,就停止拖拽

#+begin_src js
var box = document.querySelector('.box');

var dx,dy,dragAble = false; // 是否按下

box.addEventListener('mousedown',function(e){
	//清除元素身上默认的浏览器事件
	e.preventDefault();
	//求出鼠标按下那一刻，距离元素左和上的那一段距离
    	var rect = getRect(this);

        dx = e.pageX - rect.left;
        dy = e.pageY - rect.top;

        dragAble = true;
});

document.addEventListener('mousemove',functin(e){
	if(!dragAble) return;

	var x = e.pageX - dx; // 带偏移量的坐标
	var y = e.pageY - dy;
    	//把坐标赋值个box 的定位值
	box.style.left = x + 'px';
    	box.style.top = y + 'px';
});

document.addEventListener('mouseup',function(e){
	fragAble  = false; //关闭开关
});

function getRect(ele){
//获取父级的到浏览器左和上的绝对距离
	return ele.getBoundingClientRect();
}
#+end_src

** 使用DOM1级事件完成拖拽

#+begin_src js
var box = document.querySelector('box');

var dx,dy;

box.onmousedown = function (){
//阻止浏览器默认事件
	e.preventDefault();
// 为了获取鼠标当前到父级的距离
	var rect = getRect(this); 
	dx = e.pageX - rect.left;
	dy = e.pageY - rect.top;

	document.onmousemove = function (e){
		var x = e.pageX - dx;
		var y = e.pageY - dy;

		box.style.left = x + 'px';
        	box.style.top = x + 'px';
};

document.onmouseup = function (){
	this.onmousemove = this.onmoseup = null;

};

};

function getRect(ele){
	return ele.getBoundingclientRect();
}
#+end_src

** 限制拖拽区域

#+begin_src js
var box = document.querySelector('.box');

var dx,dy;

box.addEventListener('mousedown',function (e){
	//由于可能拖拽文字移动，首先要阻止这个默认行为

	e.prevetDefault();
    	
	//求出鼠标按下那一刻，距离元素左侧和上的那一段距离

	var rect = getRect(this);

	dx = e.pageX - rect.left;
	dy = e.pageY - rect.top;

	document.addEventListener('mousemove',moveDiv); //监听鼠标事件
	document.addEventListener('mouseup',cancelMoveDiv):
});

function moveDi(e){
	var x = e.pageX - dx;
	var y = e.pageY - dy;// 鼠标触发元素的位置
}

//限制拖拽范围的判断

//左侧边界条件
if(x<0) x = 0;

//右侧边界条件
if(x> window.innerWidth - box.offsetWidth){
//如果x 大于屏幕的宽度 - 元素的宽度
	x = window.innerWidth - box.offsetWidth;
// x 为 屏幕的宽度 - 元素的宽度
}

//上面的边界条件
if(y<0) y = 0;
//下面的边界条件
if(y>window.innerHeight - box.offsetHeight){
	y = window.innerHeight - box.offsetHeight;
}

function cancelMoveDiv(){
	//取消监听鼠标事件
	document.removeEventListener('mousemove',moveDiv);
	document.removeEventListener('mouseup',cancelMoveDiv);
}

//获取元素的到浏览器左和上的边界
function getRect(ele){
	return ele.getBoundingClientRect();
}
#+end_src

** 基于九宫格的碰撞检测

#+begin_src js
var target = document.querySelector('.target');

var box  = document.querySelector('.box');

var dx,dy;

box.addEventListener('mousedown',function (e){

//由于可能拖拽文字移动， 所以要先阻止这个默认行为

e.preventDefault();

//求出鼠标按下那一刻，距离元素左侧和上的那一段距离

var rect = getRect(this);
//获取到鼠标到触发元素边界的距离
dx = e.pageX - rect.left;
dy = e.pageY - rect.top; 

//按下之后可以移动

document.addEventListener('mousemove',moveDiv);
document.addEventListener('mouseup',cancelMoveDiv);
});

function moveDiv (e){
var x = e.pageX - dx ;
var y = e.pageY - dy ;

//碰撞检测
// var boxRect = getRect(box);
// var targetRect =  getRect(target);
if(boxRect.right > targetRect.left && boxRect.left < targetRect.right && 
boxRect.top < targetRect.bottom && boxRect.bottom > targetRect.top){
	target.style.backgroundColor = 'pink' ;

}else{
	target.style.backgroundColor= '';
}

function duang(ele1,ele2){
	var rect1 = ele1.getBoundingClientRect();
	var rect2 = ele2.getBoundingClientRect();
	return rect1.right > rect2.left && rect1.left<rect2.right && rect1.bottom
>rect2.top && rect1.top< rect2.bottom;
}
#+end_src

** 基本通用拖拽函数

#+begin_src js
var modalDialog = document.querySelector('.modal-dialog');

var modalHeader = document.querySelector('.moadl-header');

dragEle({
	downEle: modalHeader,
	moveEle: modalDialog
});

function dragEle(props){
	var downEle = props.downEle;
	var moveEle = props.moveEle || downEle;
    	var scope = props.scope || true;
	var cb = props.cb

	var dx,dy;
	var offsetParent = moveEle.offsetParent;
	parentRect  = getRect(offsetParent);
	
	downEle.addEventListener('mousedown',function(e){
//阻止浏览器的默认事件
	e.preventDefault();
	
	var moveTargetRectt = getRect(moveEle);
//鼠标相对于触发事件的距离
	dx = e.pageX - moveTargetRect.left;
	dy = e.pageY - moveTargetRect.top;

	document.addEventListener('mousemove',docMove);
	offsetParent.addEventListener('mousemove',startMove);
	offsetParent.addEventListener('mousup',cancelMove);
});

//触发事件的移动距离
	funcrion startMove (e){
	var x = e.pageX - dx - parentRect.left;
	var y = e.pageY - dy - parentRect.top;

	if(scope){//边界条件 
	if(x<0) x =0;
	if(x > offsetParent.clientWidth - moveEle.offsetWidth){
	x = offsetParent.clientWidth - moveEle.offsetWidth;
}

	if(y<0) y =0;

	if(y>offsetParent.clientHeight - moveEle.offsetHeight){
    y = offsetParent.clientHeight - moveEle.offsetHeight;
}
}
cb&&cb();
moveEle.style.left = x + 'px';
moveEle.style.top = y + 'px';

function cancelMove(){
	document.removeEventListener('mousemove',docMove);
	offsetParent.removeEventListener('mousemove',startMove);
	offsetParent.removeEventListener('mouseup',cancelMove);
}

//如果鼠标移出定位父级 则取消鼠标移动事件
function docMove(){
	var x = e.pageX , y= e.pageY;
if(x<parentRect.left || x>parentRect.right || y<parentRect.top || y>parentRect.bottom){
	cancelMove();
}
}
	}

function getRec(ele){
	return ele.getBoundingClientRect();
}
#+end_src

** 验证test

#+begin_src js
var target = document.querySelector('.target');
var box = docuement.querySelector('.box');

dragEle({
	downEle:box,
	cb(){
	if(duang(box,target)){
	target.style.backgroundColor = 'pink';
}else{
	target.style.backgroundColor = '';
}
}
});
#+end_src

** 8个方向上的div

#+begin_src js
var box = document.querySelector('.box');

//四个按键方向为false
#+end

* 20171101

** 鼠标滚轮事件

1.在火狐浏览器下,使用滚轮事件，必须使用DOM2级事件监听的形式，监听
'DOMMouseScroll'

2.在谷歌、IE其他浏览器下使用 mousewheel 事件

** 火狐浏览器

#+begin_src js
 window.addEventListener('DOMMouseScroll',function(e){
	console.log(e.detail);
});

e.detail 如果是向上滚动，那么是一个负数
e.detail 如果是下滚动，那么是一个正数
#+end_src

** 谷歌浏览器

#+begin_src js

  window.onmousewheel = function (){
      console.log(e.wheelDelta);
  };

  window.addEventListener('mousewheel',function (e){
      console.log(e.wheelDelta);
  });

#+end_src

e.wheelDelta 如果是向上滚动,那么是一个正数
e.wheelDelta 如果是向下滚动,那么是一个负数

** 兼容性处理 

#+begin_src js
  function mouseWheel(ele,upFn,downFn){
      if(window.onmousewheel === null){
       ele.addEventListener('mousewheel',fn);	
      }else{
      ele.addEventLisener('DOMMouseScroll',fn);
      }

      function fn(e){
      var dir;
	
      if(e.detail){
      dir = e.detail < 0 ? true : false;
      }
      if(e.wheelDelta){
      dir = e.wheelDelta > 0 ? true : false;
      }
	
         if(dir){
          upFn&&upFn.call(ele,e);
      }else{
          downFn && downFn.call(ele,e);
      }
  }
  }

  mouseWheel(document,up,down);

function up(){
	console.log(this);
	console.log(`向上滚动`);
}

function down (e){
	console.log(e);
	console.log('向下滚动');
}
#+end_src
* 20171102
** 自定义滚动条
#+begin_src html
<!DOCTYPE html>
<html>
  <head>
	<meta charset="utf-8" />
	<title></title>
	<style type="text/css">
	 h1{
		 margin: 0;
		 width: 193px;
		 height: 46px;
		 background: url(img/logo.png);
		 position: absolute;
		 top:60px;
		 left: 297px;
	 }
	 body{
		 margin: 0;
	 }
	 ul{
		 padding: 0;
		 margin: 0;
		 list-style: none;
		 position: absolute;
		 top: 0;
		 left: 0;
	 }
	 #wrap{
		 position: relative;
		 width: 712px;
		 height: 435px;
		 padding-top: 165px;
		 padding-left: 88px;
		 background: url("img/bg.png") 0 0 no-repeat;
		 display: flex;
		 justify-content: center;
		 align-items: center;
	 }
	 #wrap .scrollWrap{
		 position: relative;
	 }
	 li{
		 font: 14px/36px "宋体";
		 text-indent: 20px;
	 }
	 #listWrap {
		 width: 101px;
		 height: 387px;
		 border-radius: 10px;
		 background: rgba(0,0,0,.6);		
     color: #fff;
		 margin-right: 72px;
		 overflow: hidden;
		 position: relative;
	 }
	 #listWrap .scrollWrap{
		 position: absolute;
		 top: 11px;
		 right: 7px;
		 width:15px;
		 height: 365px;
		 /*background: rgba(0,0,0,.8);*/
		 background: #fff;
		 border-radius: 5px;
	 }
	 #listWrap .scrollBar {
		 width: 13px;
		 height: 90px;
		 position: absolute;
		 top: 0px;
		 left: 1px;
		 background: url(img/s2.png) no-repeat;
	 }
	</style>
  </head>
  <body>
	<section id="wrap">
	  <h1></h1>
	  <div id="listWrap">
		<ul id="listItems">
		  <li>北京</li>
		  <li>上海</li>
		  <li>广州</li>
		  <li>深圳</li>
		  <li>重庆</li>
		  <li>成都</li>
		  <li>武汉</li>
		  <li>哈尔滨</li>
		  <li>沈阳</li>
		  <li>长春</li>
		  <li>大连</li>
		  <li>石家庄</li>
		  <li>西安</li>
		  <li>贵阳</li>
		  <li>天津</li>
		  <li>厦门</li>
		</ul>
		<div class="scrollWrap">
		  <div class="scrollBar"></div>
		</div>
	  </div>
	</section>
  </body>
  <script src="../tools.js"></script>
<script></script>
</html>

#+end_src

#+begin_src js
var listWrap =  document.getElementById('listWrap');
var listItems = document.getElementById('listItems');
var scrollWrap = document.querySelector('.scrollWrap');
var scrollBar = document.querySelector('.scrollBar');
var listWrapHeight = listWrap.clientHeight;
var listItemsHeight = listItems.offsetHeight;
var scrollWrapHeight = scrollWrap.clientHeight;
var scrollBarHeight = scrollBar.offsetHeight;

var maxListTop = listItemsHeight - listWrapHeight;
var maxScrollTop = scrollWrapHeight - scrollBarHeight;

var scrollSize = listWrapHeight / listItemsHeight*scrollWrapHeight;

dragEle({
	downEle: scrollBar,
    	disableX: true,
       moveScrop: document,
       moveFn(){
       	var scale = this.offsetTop / maxScrollTop;
        listItems.style.top = -scale*maxListTop + 'px';
       }
});

mouseWheel(listWrap,scrollUp,scrollDown)

function scrollUp(){
	var t = Math.map(0,scrollBar.offsetTop - scrollSize);
    	var scale = scrollBar.offsetTop / maxScrollTop;
        scrollBar.style.top = t + 'px';
        listItems.style.top = -scale*maxListTop + 'px';
}

function scrollDown(){

	var t = Math.min(scrollBar.offsetTop + scrollSize,maxScrolTop);
    var scale = scrollBar.offsetTop / maxScrollTop;
    scrollBar.style.top = t +'px';
    listItems.style.top = -scale*maxListTop + 'px';
}
#+end_src

** 邮箱拖拽删除

#+begin_src js
var beenDel = document.querySelector('.beenDel');

var checkAll = document.getElementById('checkAll');

var emailWrap = document.getElementById('email');
var emailItems = emailWrap.children;
var hint  = document.getElementById('hint3');

function createHtml(data){
	emailWrap.innerHTML = '';
    	for(var i=0; i<data.length; i++){
        	var li = document.createElement('li');
              li.eld = data[i].id;
              li.innerHTML = `<input type="checkbox" />
											<div>
												<span>${data[i].caption}</span>
												<span>${data[i].time}</span>
											</div>
											<p>${data[i].desc}</p>`;
           emailWrap.appendChild(li);
        }
}

creatHtml(list);

var checkedNum = 0;

for(var i=0; i<emailItems.length; i++){
	emailItems[i].firstELementChild.onclick = function (){
    	     if(this.checked){
             	checkedNum ++;
		}else{
			checkedNum --;
		}
        checkAll.check = checkedNum === list.length;
	};

    emailItems[i].onmousdown = function(e){
	e.preventDefault();

    if(!this.firstElementChild.checked) returm;
    
  hint,innerHTML = `选中${checkedNum}封邮件`;  
  
  document.onmousemove = function (e){
	var x = e.pageX, y = e.pageY;
    hint.style.left = x + 'px';
    hint.style.top = y + 'px';
};
document.onmouseup = function (e){
	var x = e.pageX, y = e.pageY;

	if(toRecycleBin(x,y)){
    deleteCheckedEmail();
    }

    hint.style.left = '-99px';
    this.onmouseup = this.onmousemove = null;
};
};
}

checkAll.onclick = function (){
	if(this.checked){
    checkedNum = list.length;
}else{
	checkNum = 0;
}

for(var i =0 ; i<emailItems.length; i++){
emailItems[i].firstElementChild.checked = this.checked;
}
};

function deleteCheckedEmail(){
	for(var i=0; i<emailItems.length; i++){
    		if(emailItems[i].firstElementChild,checked){
			var eld = emailItems[i].eld;
            emailWrap.removeChild(emailItems[i]);
            list = list.filter(function(item){
	return item.id !==eld;
});
i--
}
}
//删除完毕之后没有选中的邮件了
checkNum = 0;
 check.checked = false;
}
// var checkedBuffer = {length:0};
// checkedBuffer[eld] = this.parentNode;
#+end_src
* 20171115
** 贪婪模式(greedy)
贪婪模式和非贪婪模式

尽可能多的进行匹配

#+begin_src js
  console.log('123456'.replace(/\d{2,4}/,'x'));
#+end_src

尽可能少的进行匹配
#+begin_src js
console.log('123456'.replace(/\d{2,4}?/),'X');
#+end_src

** 分组
分组：正则中可以使用小括号进行分组

#+begin_src js
console.log('objobjobj123'.replace(/(obj){3}/,''));
#+end_src

** COMMENT 匹配子项

使用了分组之后，从左向右看，每一个小括号代表一个子项，顺序是依次排开的

#+begin_src js
  console.log('2017-11-15'.replace(/(\d{4}(-))(\d{2})-(\d{2})/),'$2');
#+end_src

#+begin_src js
console.log('2017-11-15'.replace(/(\d{4})-(\d{2})-(\d{2})/,'$2/$3/$1'))
#+end_src
* 作业详解
** [[d:\学习指南\2-javascript\20170908\作业讲解\模拟手机短信发送\index.html][模拟手机短信发送]]
** [[D:\学习指南\2-javascript\20170911\作业讲解\图片切换综合实例\index.html][图片切换综合应用]]
** [[D:\学习指南\2-javascript\20170911\作业讲解\4个V\index.html][4个V]]


